{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"Watchtower  <p>   A solution for automating Docker container image updates </p>"},{"location":"advanced-features/http-api/","title":"HTTP API","text":""},{"location":"advanced-features/http-api/#overview","title":"Overview","text":"<p>Watchtower has an optional HTTP API server.</p> <p>Caution</p> <p>This is a relatively simple API with significant security implications.</p>"},{"location":"advanced-features/http-api/#endpoints","title":"Endpoints","text":"Name Endpoint Parameters Description Update <code>/v1/update</code> <code>image</code> Triggers container updates and returns JSON results of the operation Metrics <code>/v1/metrics</code> Exposes Prometheus-compatible metrics for monitoring and alerting"},{"location":"advanced-features/http-api/#http_api_update","title":"HTTP API Update","text":"<p>To enable this mode, use the <code>--http-api-update</code> CLI argument or the <code>WATCHTOWER_HTTP_API_UPDATE</code> environment variable.</p>"},{"location":"advanced-features/http-api/#response_format","title":"Response Format","text":"<p>The <code>/v1/update</code> endpoint returns a JSON response containing the results of the update operation:</p> <pre><code>{\n  \"summary\": {\n    \"scanned\": 8,\n    \"updated\": 0,\n    \"failed\": 0,\n    \"restarted\": 0\n  },\n  \"timing\": {\n    \"duration_ms\": 1250,\n    \"duration\": \"1.25s\"\n  },\n  \"timestamp\": \"2025-01-20T11:30:45Z\",\n  \"api_version\": \"v1\"\n}\n</code></pre> <p>Summary Section:</p> <ul> <li><code>scanned</code>: Number of containers that were scanned for updates</li> <li><code>updated</code>: Number of containers that were successfully updated</li> <li><code>failed</code>: Number of containers where the update failed</li> <li><code>restarted</code>: Number of containers that were restarted due to linked dependencies</li> </ul> <p>Restarted containers represent containers that were restarted because they have dependencies on other containers that were updated. This is part of Watchtower's linked container functionality, which ensures that dependent services are restarted when their linked containers are updated to maintain consistency.</p> <p>Timing Section:</p> <ul> <li><code>duration_ms</code>: Execution time in milliseconds</li> <li><code>duration</code>: Human-readable execution time</li> </ul> <p>Metadata:</p> <ul> <li><code>timestamp</code>: UTC timestamp when the response was generated (RFC3339 format)</li> <li><code>api_version</code>: API version identifier</li> </ul>"},{"location":"advanced-features/http-api/#requirements","title":"Requirements","text":""},{"location":"advanced-features/http-api/#authentication","title":"Authentication","text":"<p>Watchtower uses token-based, header authentication for the HTTP API.</p> <p>This should be set using the HTTP API Token configuration option.</p> <p>All requests to the <code>/v1/update</code> endpoint will require an <code>Authorization: Bearer &lt;token&gt;</code> header with the predefined HTTP API token value.</p>"},{"location":"advanced-features/http-api/#address_and_port_configuration","title":"Address and Port Configuration","text":"<p>Watchtower defaults to listening on all interfaces on port 8080. The port can be changed using the HTTP API Port configuration option. To bind to a specific host, use the HTTP API Host configuration option. The host must be a valid IP address (IPv4 or IPv6).</p> <p>Alternatively, if Watchtower is being run via a Docker container, then the <code>host:container</code> port mapping can be updated accordingly (e.g. <code>8080:8080</code> -&gt; <code>9000:8080</code>).</p>"},{"location":"advanced-features/http-api/#examples","title":"Examples","text":"<ul> <li>Listen on all interfaces on port 8080 (default):</li> </ul> <pre><code>--http-api-port=8080\n</code></pre> <ul> <li>Listen on localhost only on port 8080:</li> </ul> <pre><code>--http-api-host=127.0.0.1 --http-api-port=8080\n</code></pre> <ul> <li>Listen on a specific IP and port:</li> </ul> <pre><code>--http-api-host=192.168.1.100 --http-api-port=9090\n</code></pre>"},{"location":"advanced-features/http-api/#image_parameter_usage","title":"Image Parameter Usage","text":"<p>Watchtower supports using the <code>image</code> URL query parameter to filter updates for only certain images.</p>"},{"location":"advanced-features/http-api/#no_image_filtering","title":"No Image Filtering","text":"<p>The following <code>curl</code> command would trigger an update of all container images monitored by Watchtower:</p> <pre><code>curl -H \"Authorization: Bearer mytoken\" localhost:8080/v1/update\n</code></pre>"},{"location":"advanced-features/http-api/#image_filtering_with_tags","title":"Image Filtering with Tags","text":"<p>You can specify image tags to target containers running a specific version (e.g., <code>foo/bar:1.0</code>).</p> <p>For example, to update only containers using <code>foo/bar:1.0</code> and <code>foo/baz:latest</code>:</p> <pre><code>curl -H \"Authorization: Bearer mytoken\" localhost:8080/v1/update?image=foo/bar:1.0,foo/baz:latest\n</code></pre>"},{"location":"advanced-features/http-api/#image_filtering_without_tags","title":"Image Filtering without Tags","text":"<p>If no tag is provided, Watchtower matches containers regardless of their tag.</p> <p>The following <code>curl</code> command would trigger an update for the images <code>foo/bar</code> and <code>foo/baz</code>:</p> <pre><code>curl -H \"Authorization: Bearer mytoken\" localhost:8080/v1/update?image=foo/bar,foo/baz\n</code></pre>"},{"location":"advanced-features/http-api/#scheduled_updates","title":"Scheduled Updates","text":"<p>By default, enabling this mode prevents periodic polls (i.e. scheduled or interval polling). Use the HTTP API Periodic Polls configuration option to allow both API-triggered and scheduled updates.</p>"},{"location":"advanced-features/http-api/#example","title":"Example","text":"Example Docker Compose Configuration<pre><code>services:\n  app-monitored-by-watchtower:\n    image: myapps/monitored-by-watchtower\n    labels:\n      - \"com.centurylinklabs.watchtower.enable=true\"\n\n  watchtower:\n    image: nickfedor/watchtower\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n    command: --http-api-update --http-api-metrics\n    environment:\n      - WATCHTOWER_HTTP_API_TOKEN=mytoken\n    labels:\n      - \"com.centurylinklabs.watchtower.enable=false\"\n    ports:\n      - 8080:8080\n    restart: unless-stopped\n</code></pre> <p>Note</p> <p>Both <code>--http-api-update</code> and <code>--http-api-metrics</code> can be enabled simultaneously to provide both update triggering and monitoring capabilities.</p>"},{"location":"advanced-features/lifecycle-hooks/","title":"Lifecycle Hooks","text":"<p>Watchtower's lifecycle hooks are a feature that allows monitored containers to execute custom commands at specific points during the container update process. These hooks leverage Docker's exec API to run commands inside containers.</p>"},{"location":"advanced-features/lifecycle-hooks/#overview","title":"Overview","text":"<p>Lifecycle hooks enable containers to perform custom actions such as:</p> <ul> <li>Graceful shutdown procedures</li> <li>Database backups or migrations</li> <li>Configuration validation</li> <li>Notification systems</li> <li>Cleanup operations</li> </ul>"},{"location":"advanced-features/lifecycle-hooks/#hook_types","title":"Hook Types","text":"<p>Watchtower supports four distinct lifecycle hook types that execute at different stages of the update process:</p> Hook Type Description Execution Timing Pre-check Executed for each filtered container before the update cycle begins Per container, before scanning containers Pre-update Executed before stopping the old container Per container, immediately before stopping Post-update Executed after starting the new container Per container, immediately after starting Post-check Executed for each filtered container after the update cycle completes Per container, after all updates"},{"location":"advanced-features/lifecycle-hooks/#configuration","title":"Configuration","text":""},{"location":"advanced-features/lifecycle-hooks/#enabling_lifecycle_hooks","title":"Enabling Lifecycle Hooks","text":"<p>Lifecycle hooks are disabled by default. Enable them by using the following on the Watchtower container:</p> Command Line FlagEnvironment Variable <pre><code>--enable-lifecycle-hooks\n</code></pre> <pre><code>WATCHTOWER_LIFECYCLE_HOOKS=true\n</code></pre>"},{"location":"advanced-features/lifecycle-hooks/#defining_hook_commands","title":"Defining Hook Commands","text":"<p>Hook commands are defined using Docker labels on the containers being monitored by Watchtower:</p> <p>Important</p> <p>These commands require all necessary tooling (i.e. <code>sh</code>, <code>jq</code>, etc.) to be installed in the monitored container.</p> Example pre-check hook (runs for each filtered container)<pre><code>LABEL com.centurylinklabs.watchtower.lifecycle.pre-check=\"echo 'Starting update cycle'\"\n</code></pre> Example pre-update hook (runs before each container update)<pre><code>LABEL com.centurylinklabs.watchtower.lifecycle.pre-update=\"echo 'Preparing container for update'\"\n</code></pre> Example post-update hook (runs after each container update)<pre><code>LABEL com.centurylinklabs.watchtower.lifecycle.post-update=\"echo 'Container updated successfully'\"\n</code></pre> Example post-check hook (runs for each filtered container)<pre><code>LABEL com.centurylinklabs.watchtower.lifecycle.post-check=\"echo 'Update cycle completed'\"\n</code></pre> <p>Note</p> <p>If the container is not running, lifecycle hooks (including pre-update hooks) cannot run, as the stop phase is skipped, and the update proceeds directly to removal (if applicable) or completion.</p>"},{"location":"advanced-features/lifecycle-hooks/#advanced_configuration","title":"Advanced Configuration","text":""},{"location":"advanced-features/lifecycle-hooks/#custom_timeouts","title":"Custom Timeouts","text":"<p>By default, hook commands timeout after 1 minute. Override this with timeout labels:</p> Pre-check timeoutPost-check timeoutPre-update timeoutPost-update timeout Set pre-check timeout to 5 minutes<pre><code>LABEL com.centurylinklabs.watchtower.lifecycle.pre-check-timeout=\"5\"\n</code></pre> Disable pre-check timeout (run indefinitely)<pre><code>LABEL com.centurylinklabs.watchtower.lifecycle.pre-check-timeout=\"0\"\n</code></pre> Set post-check timeout to 5 minutes<pre><code>LABEL com.centurylinklabs.watchtower.lifecycle.post-check-timeout=\"5\"\n</code></pre> Disable post-check timeout (run indefinitely)<pre><code>LABEL com.centurylinklabs.watchtower.lifecycle.post-check-timeout=\"0\"\n</code></pre> Set pre-update timeout to 5 minutes<pre><code>LABEL com.centurylinklabs.watchtower.lifecycle.pre-update-timeout=\"5\"\n</code></pre> Disable pre-update timeout (run indefinitely)<pre><code>LABEL com.centurylinklabs.watchtower.lifecycle.pre-update-timeout=\"0\"\n</code></pre> Set post-update timeout to 5 minutes<pre><code>LABEL com.centurylinklabs.watchtower.lifecycle.post-update-timeout=\"5\"\n</code></pre> Disable post-update timeout (run indefinitely)<pre><code>LABEL com.centurylinklabs.watchtower.lifecycle.post-update-timeout=\"0\"\n</code></pre>"},{"location":"advanced-features/lifecycle-hooks/#custom_user_execution","title":"Custom User Execution","text":"<p>By default, hooks run as the monitored container's configured user and group (<code>uid:gid</code>).</p> <p>Both global and individual, container-specific uid/gid configurations are supported.</p> <p>Note</p> <p>Container labels take precedence over global flags/variables.</p> Global ConfigurationIndividual Container Configuration Command Line FlagsEnvironment Variables <p>Global UID for all hooks<pre><code>--lifecycle-uid 1000\n</code></pre> Global GID for all hooks<pre><code>--lifecycle-gid 1000\n</code></pre></p> Global UID for all hooks<pre><code>WATCHTOWER_LIFECYCLE_UID=1000\n</code></pre> Global GID for all hooks<pre><code>WATCHTOWER_LIFECYCLE_GID=1000\n</code></pre> Run hooks as user ID 1000<pre><code>LABEL com.centurylinklabs.watchtower.lifecycle.uid=\"1000\"\n</code></pre> Run hooks as user ID 1000 and group ID 1000<pre><code>LABEL com.centurylinklabs.watchtower.lifecycle.uid=\"1000\"\nLABEL com.centurylinklabs.watchtower.lifecycle.gid=\"1000\"\n</code></pre>"},{"location":"advanced-features/lifecycle-hooks/#execution_details","title":"Execution Details","text":""},{"location":"advanced-features/lifecycle-hooks/#docker_api_integration","title":"Docker API Integration","text":"<p>Lifecycle hooks utilize Docker's exec API through the following sequence:</p> <ol> <li>Exec Creation: <code>ContainerExecCreate</code> creates an exec instance with the specified command</li> <li>Exec Start: <code>ContainerExecStart</code> begins execution of the command</li> <li>Output Capture: <code>ContainerExecAttach</code> captures stdout/stderr output</li> <li>Status Monitoring: <code>ContainerExecInspect</code> monitors execution status and exit codes</li> </ol>"},{"location":"advanced-features/lifecycle-hooks/#environment_variables","title":"Environment Variables","text":"<p>Lifecycle hook commands receive container metadata via the <code>WT_CONTAINER</code> environment variable containing a JSON object with the following fields:</p> Field Type Description Example <code>name</code> string Container name (may include leading <code>/</code>) <code>\"/my-app\"</code> or <code>\"my-app\"</code> <code>id</code> string Full container ID <code>\"abc123def456...\"</code> <code>image_name</code> string Container image name with tag <code>\"nginx:latest\"</code> <code>stop_signal</code> string Container's configured stop signal <code>\"SIGTERM\"</code> <code>labels</code> object Watchtower-specific labels only <code>{\"com.centurylinklabs.watchtower.lifecycle.pre-update\": \"backup.sh\"}</code> <p>Note</p> <p>The <code>labels</code> object contains only Watchtower-specific labels (those starting with <code>com.centurylinklabs.watchtower.</code>) to keep the JSON payload small and focused on Watchtower configuration.</p>"},{"location":"advanced-features/lifecycle-hooks/#usage_examples","title":"Usage Examples","text":"BashPythonGoConditional Logic Container NameContainer IDImage NameLabelsStop Signal <pre><code>#!/bin/bash\nCONTAINER_NAME=$(echo $WT_CONTAINER | jq -r '.name')\necho \"Processing container: $CONTAINER_NAME\"\n</code></pre> <pre><code>#!/bin/bash\nCONTAINER_ID=$(echo $WT_CONTAINER | jq -r '.id')\necho \"Container ID: $CONTAINER_ID\"\n</code></pre> <pre><code>#!/bin/bash\nIMAGE=$(echo $WT_CONTAINER | jq -r '.image_name')\necho \"Image: $IMAGE\"\n</code></pre> <pre><code>#!/bin/bash\nBACKUP_SCRIPT=$(echo $WT_CONTAINER | jq -r '.labels[\"com.centurylinklabs.watchtower.lifecycle.pre-update\"]')\nif [ -n \"$BACKUP_SCRIPT\" ]; then\n    echo \"Running backup: $BACKUP_SCRIPT\"\n    $BACKUP_SCRIPT\nfi\n</code></pre> <pre><code>#!/bin/bash\nSIGNAL=$(echo $WT_CONTAINER | jq -r '.stop_signal')\necho \"Stop signal: $SIGNAL\"\n</code></pre> Container NameContainer IDImage NameLabelsStop Signal <pre><code>import os\nimport json\n\ncontainer_info = json.loads(os.environ['WT_CONTAINER'])\nprint(f\"Processing container: {container_info['name']}\")\n</code></pre> <pre><code>import os\nimport json\n\ncontainer_info = json.loads(os.environ['WT_CONTAINER'])\nprint(f\"Container ID: {container_info['id']}\")\n</code></pre> <pre><code>import os\nimport json\n\ncontainer_info = json.loads(os.environ['WT_CONTAINER'])\nprint(f\"Image: {container_info['image_name']}\")\n</code></pre> <pre><code>import os\nimport json\n\ncontainer_info = json.loads(os.environ['WT_CONTAINER'])\nbackup_script = container_info['labels'].get('com.centurylinklabs.watchtower.lifecycle.pre-update')\nif backup_script:\n    print(f\"Running backup: {backup_script}\")\n    # Execute backup_script\n</code></pre> <pre><code>import os\nimport json\n\ncontainer_info = json.loads(os.environ['WT_CONTAINER'])\nprint(f\"Stop signal: {container_info['stop_signal']}\")\n</code></pre> Container NameContainer IDImage NameLabelsStop Signal <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    var container struct {\n        Name string `json:\"name\"`\n    }\n\n    if err := json.Unmarshal([]byte(os.Getenv(\"WT_CONTAINER\")), &amp;container); err != nil {\n        panic(err)\n    }\n\n    fmt.Printf(\"Processing container: %s\\n\", container.Name)\n}\n</code></pre> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    var container struct {\n        ID string `json:\"id\"`\n    }\n\n    if err := json.Unmarshal([]byte(os.Getenv(\"WT_CONTAINER\")), &amp;container); err != nil {\n        panic(err)\n    }\n\n    fmt.Printf(\"Container ID: %s\\n\", container.ID)\n}\n</code></pre> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    var container struct {\n        ImageName string `json:\"image_name\"`\n    }\n\n    if err := json.Unmarshal([]byte(os.Getenv(\"WT_CONTAINER\")), &amp;container); err != nil {\n        panic(err)\n    }\n\n    fmt.Printf(\"Image: %s\\n\", container.ImageName)\n}\n</code></pre> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    var container struct {\n        Labels map[string]string `json:\"labels\"`\n    }\n\n    if err := json.Unmarshal([]byte(os.Getenv(\"WT_CONTAINER\")), &amp;container); err != nil {\n        panic(err)\n    }\n\n    if backupScript, exists := container.Labels[\"com.centurylinklabs.watchtower.lifecycle.pre-update\"]; exists {\n        fmt.Printf(\"Running backup: %s\\n\", backupScript)\n        // Execute backupScript\n    }\n}\n</code></pre> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    var container struct {\n        StopSignal string `json:\"stop_signal\"`\n    }\n\n    if err := json.Unmarshal([]byte(os.Getenv(\"WT_CONTAINER\")), &amp;container); err != nil {\n        panic(err)\n    }\n\n    fmt.Printf(\"Stop signal: %s\\n\", container.StopSignal)\n}\n</code></pre> Image-Based LogicLabel-Based LogicContainer State Logic <pre><code>#!/bin/bash\nIMAGE=$(echo $WT_CONTAINER | jq -r '.image_name')\nif [[ $IMAGE == *\"postgres\"* ]]; then\n    echo \"Running PostgreSQL-specific backup\"\n    pg_dump mydb &gt; backup.sql\nelif [[ $IMAGE == *\"mysql\"* ]]; then\n    echo \"Running MySQL-specific backup\"\n    mysqldump mydb &gt; backup.sql\nfi\n</code></pre> <pre><code>#!/bin/bash\nBACKUP_TYPE=$(echo $WT_CONTAINER | jq -r '.labels[\"com.centurylinklabs.watchtower.backup-type\"] // \"default\"')\ncase $BACKUP_TYPE in\n    \"full\")\n        echo \"Performing full backup\"\n        # Full backup logic\n        ;;\n    \"incremental\")\n        echo \"Performing incremental backup\"\n        # Incremental backup logic\n        ;;\n    *)\n        echo \"Performing default backup\"\n        # Default backup logic\n        ;;\nesac\n</code></pre> <pre><code>#!/bin/bash\nCONTAINER_NAME=$(echo $WT_CONTAINER | jq -r '.name')\n\n# Check if this is a production container\nif [[ $CONTAINER_NAME == *\"prod\"* ]]; then\n    echo \"Production container - extra caution\"\n    # Additional safety checks\nelse\n    echo \"Non-production container - proceeding\"\nfi\n</code></pre>"},{"location":"advanced-features/lifecycle-hooks/#execution_flow","title":"Execution Flow","text":""},{"location":"advanced-features/lifecycle-hooks/#complete_update_cycle","title":"Complete Update Cycle","text":"<pre><code>flowchart TD\n    START([START])\n    START --&gt; PRECHECK\n    PRECHECK[Pre-check hook]\n    PRECHECK --&gt; SCAN\n    SCAN[Scan for updates&lt;br/&gt;Check images&lt;br/&gt;Find stale containers]\n    SCAN --&gt; DECISION{Stale containers&lt;br/&gt;found?}\n    DECISION --&gt;|No| POSTCHECK\n    DECISION --&gt;|Yes| LOOPSTART\n    LOOPSTART[For each stale container]\n    LOOPSTART --&gt; PREUPDATE\n    PREUPDATE[Pre-update hook]\n    PREUPDATE --&gt; STOP[Stop old container]\n    STOP --&gt; STARTNEW[Start new container]\n    STARTNEW --&gt; POSTUPDATE[Post-update hook]\n    POSTUPDATE --&gt; LOOPEND{All containers&lt;br/&gt;processed?}\n    LOOPEND --&gt;|No| LOOPSTART\n    LOOPEND --&gt;|Yes| POSTCHECK\n    POSTCHECK[Post-check hook]\n    POSTCHECK --&gt; END([END])\n\n    classDef hook fill:#406170,stroke:#000,stroke-width:2px;\n    classDef action fill:#003343,stroke:#000,stroke-width:2px;\n    classDef decision fill:#003343,stroke:#000,stroke-width:2px;\n\n    class PRECHECK,PREUPDATE,POSTUPDATE,POSTCHECK hook\n    class SCAN,STOP,STARTNEW,LOOPSTART action\n    class DECISION,LOOPEND decision</code></pre>"},{"location":"advanced-features/lifecycle-hooks/#hook_execution_conditions","title":"Hook Execution Conditions","text":"Hook Type Scope Timing Conditions Container State Pre-check Per filtered container Beginning of update cycle Command defined + hooks enabled Ignored Pre-update Individual containers being updated Immediately before stopping Command defined + hooks enabled + container running + not restarting Must be running and not restarting Post-update Individual containers successfully updated Immediately after starting new container Command defined + hooks enabled + update successful New container running Post-check Per filtered container End of update cycle Command defined + hooks enabled Ignored"},{"location":"advanced-features/lifecycle-hooks/#exit_code_handling","title":"Exit Code Handling","text":"<p>Hook execution results are evaluated based on exit codes, with different behaviors per hook type:</p> Pre-checkPre-updatePost-updatePost-check <p>Failures are logged but ignored; update process continues</p> Exit Code Description Action 0 Success Continue with update process 75 (EX_TEMPFAIL) Temporary failure Skip updating this container Other Exit Codes Command failure Abort the update process <p>Failures are logged but ignored; update process continues</p> <p>Failures are logged but ignored; update process continues</p>"},{"location":"advanced-features/lifecycle-hooks/#practical_examples","title":"Practical Examples","text":"Database Backup and MigrationApplication Graceful ShutdownNotification SystemConditional Updates DockerfileDocker Compose <pre><code>FROM postgres:13\n\n# Pre-update: Create backup before stopping\nLABEL com.centurylinklabs.watchtower.lifecycle.pre-update=\"/usr/local/bin/backup.sh\"\nLABEL com.centurylinklabs.watchtower.lifecycle.pre-update-timeout=\"10\"\n\n# Post-update: Run migrations after starting new version\nLABEL com.centurylinklabs.watchtower.lifecycle.post-update=\"/usr/local/bin/migrate.sh\"\nLABEL com.centurylinklabs.watchtower.lifecycle.post-update-timeout=\"15\"\n\nCOPY backup.sh migrate.sh /usr/local/bin/\nRUN chmod +x /usr/local/bin/backup.sh /usr/local/bin/migrate.sh\n</code></pre> <pre><code>version: '3.8'\nservices:\n  postgres:\n    image: postgres:13\n    environment:\n      POSTGRES_DB: mydb\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: pass\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n      - ./backup.sh:/usr/local/bin/backup.sh:ro\n      - ./migrate.sh:/usr/local/bin/migrate.sh:ro\n    labels:\n      - \"com.centurylinklabs.watchtower.lifecycle.pre-update=/usr/local/bin/backup.sh\"\n      - \"com.centurylinklabs.watchtower.lifecycle.pre-update-timeout=10\"\n      - \"com.centurylinklabs.watchtower.lifecycle.post-update=/usr/local/bin/migrate.sh\"\n      - \"com.centurylinklabs.watchtower.lifecycle.post-update-timeout=15\"\n\n  watchtower:\n    image: nicholas-fedor/watchtower\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n    environment:\n      - WATCHTOWER_LIFECYCLE_HOOKS=true\n      - WATCHTOWER_POLL_INTERVAL=30\n\nvolumes:\n  postgres_data:\n</code></pre> DockerfileDocker Compose <pre><code>FROM node:18\n\n# Pre-update: Signal application to shutdown gracefully\nLABEL com.centurylinklabs.watchtower.lifecycle.pre-update=\"pkill -TERM node\"\nLABEL com.centurylinklabs.watchtower.lifecycle.pre-update-timeout=\"2\"\n\n# Post-update: Wait for application to be ready\nLABEL com.centurylinklabs.watchtower.lifecycle.post-update=\"/wait-for-app.sh\"\nLABEL com.centurylinklabs.watchtower.lifecycle.post-update-timeout=\"5\"\n\nCOPY wait-for-app.sh /\nRUN chmod +x /wait-for-app.sh\n</code></pre> <pre><code>version: '3.8'\nservices:\n  node-app:\n    image: node:18\n    working_dir: /app\n    volumes:\n      - ./app:/app\n      - ./wait-for-app.sh:/wait-for-app.sh:ro\n    ports:\n      - \"3000:3000\"\n    command: npm start\n    labels:\n      - \"com.centurylinklabs.watchtower.lifecycle.pre-update=pkill -TERM node\"\n      - \"com.centurylinklabs.watchtower.lifecycle.pre-update-timeout=2\"\n      - \"com.centurylinklabs.watchtower.lifecycle.post-update=/wait-for-app.sh\"\n      - \"com.centurylinklabs.watchtower.lifecycle.post-update-timeout=5\"\n\n  watchtower:\n    image: nicholas-fedor/watchtower\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n    environment:\n      - WATCHTOWER_LIFECYCLE_HOOKS=true\n      - WATCHTOWER_POLL_INTERVAL=30\n</code></pre> DockerfileDocker Compose <pre><code>FROM alpine:latest\n\n# Pre-check: Send start notification\nLABEL com.centurylinklabs.watchtower.lifecycle.pre-check=\"curl -X POST -d 'Update cycle starting' http://notification-service/start\"\n\n# Post-check: Send completion notification\nLABEL com.centurylinklabs.watchtower.lifecycle.post-check=\"curl -X POST -d 'Update cycle completed' http://notification-service/complete\"\n\n# Pre-update: Notify about specific container\nLABEL com.centurylinklabs.watchtower.lifecycle.pre-update=\"curl -X POST -d \\\"Updating $(echo $WT_CONTAINER | jq -r '.name')\\\" http://notification-service/updating\"\n</code></pre> <pre><code>version: '3.8'\nservices:\n  notification-service:\n    image: alpine:latest\n    volumes:\n      - ./notify.sh:/usr/local/bin/notify.sh:ro\n    labels:\n      - \"com.centurylinklabs.watchtower.lifecycle.pre-check=curl -X POST -d 'Update cycle starting' http://notification-service/start\"\n      - \"com.centurylinklabs.watchtower.lifecycle.post-check=curl -X POST -d 'Update cycle completed' http://notification-service/complete\"\n      - \"com.centurylinklabs.watchtower.lifecycle.pre-update=/usr/local/bin/notify.sh\"\n\n  watchtower:\n    image: nicholas-fedor/watchtower\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n    environment:\n      - WATCHTOWER_LIFECYCLE_HOOKS=true\n      - WATCHTOWER_POLL_INTERVAL=30\n</code></pre> Dockerfile <pre><code>FROM myapp:latest\n\n# Pre-update: Check if update is safe\nLABEL com.centurylinklabs.watchtower.lifecycle.pre-update=\"/bin/bash -c 'if [ -f /tmp/maintenance ]; then exit 75; else exit 0; fi'\"\n\n# Use exit code 75 to skip updates during maintenance\n</code></pre>"},{"location":"advanced-features/lifecycle-hooks/#synology_dsm_graceful_shutdown","title":"Synology DSM Graceful Shutdown","text":"<p>Warning</p> <p>This is an example implementation that requires additional testing and validation.</p> <p>There is a well-known issue with Synology devices sending warning notifications when containers are stopped by anything other than the Synology's Docker service. This can be problematic when using tools like Watchtower that stop and restart containers.</p> <p>The examples/lifecycle-hooks/synology-stop directory provides examples for implementing graceful shutdowns using Synology's DSM Web API. This includes both shell script and Go implementations that authenticate with DSM, stop containers gracefully, and handle session management.</p> <p>See the synology-stop README for detailed setup instructions, environment variables, and deployment examples using docker-compose.</p>"},{"location":"advanced-features/lifecycle-hooks/#troubleshooting","title":"Troubleshooting","text":""},{"location":"advanced-features/lifecycle-hooks/#common_issues","title":"Common Issues","text":""},{"location":"advanced-features/lifecycle-hooks/#hook_commands_not_executing","title":"Hook Commands Not Executing","text":"<ul> <li>Verify <code>--enable-lifecycle-hooks</code> / <code>WATCHTOWER_LIFECYCLE_HOOKS=true</code> is set</li> <li>Check that labels are correctly formatted</li> <li>Ensure container is running (for pre-update hooks)</li> </ul>"},{"location":"advanced-features/lifecycle-hooks/#timeout_errors","title":"Timeout Errors","text":"<ul> <li>Increase timeout values using timeout labels</li> <li>Set timeout to \"0\" to disable timeouts</li> <li>Check command execution time</li> </ul>"},{"location":"advanced-features/lifecycle-hooks/#permission_issues","title":"Permission Issues","text":"<ul> <li>Use appropriate UID/GID labels</li> <li>Ensure user has permissions to execute commands</li> <li>Check container's user configuration</li> </ul>"},{"location":"advanced-features/lifecycle-hooks/#exit_code_confusion","title":"Exit Code Confusion","text":"<ul> <li>Exit code 0: Success, continue</li> <li>Exit code 75: Skip this container update</li> <li>Other codes: Fail the entire update process</li> </ul>"},{"location":"advanced-features/lifecycle-hooks/#debugging","title":"Debugging","text":"<p>Enable debug logging to see hook execution details:</p> <pre><code>watchtower --debug --enable-lifecycle-hooks\n</code></pre> <p>Look for log messages containing:</p> <ul> <li>\"Executing pre-check command\"</li> <li>\"Executing pre-update command\"</li> <li>\"Command output captured\"</li> <li>\"Command execution failed\"</li> </ul>"},{"location":"advanced-features/linked-containers/","title":"Linked Containers","text":"<p>Watchtower's linked containers feature ensures that interdependent containers are updated in the correct order to maintain application stability. This feature automatically detects container dependencies through various mechanisms and uses topological sorting to determine the optimal update sequence.</p>"},{"location":"advanced-features/linked-containers/#overview","title":"Overview","text":"<p>When containers have dependencies on each other (such as a web application depending on a database), updating them in the wrong order can cause service disruptions.</p> <p>Watchtower addresses this by:</p> <ul> <li>Detecting dependencies through Docker links, labels, and network configurations</li> <li>Performing topological sorting to determine the correct update order</li> <li>Stopping containers in reverse dependency order (dependents first - i.e., web app before database)</li> <li>Restarting containers in dependency order (dependencies first - i.e., database before web app)</li> </ul> <p>This ensures that dependent services are stopped before their dependencies are updated, and dependencies are available when dependents restart.</p>"},{"location":"advanced-features/linked-containers/#how_it_works","title":"How It Works","text":""},{"location":"advanced-features/linked-containers/#dependency_detection","title":"Dependency Detection","text":"<p>Watchtower detects container dependencies through multiple mechanisms, checked in the following priority order:</p> <ol> <li>Watchtower depends-on label (<code>com.centurylinklabs.watchtower.depends-on</code>)</li> <li>Docker Compose depends_on label (<code>com.docker.compose.depends_on</code>)</li> <li>Docker links and network mode (legacy Docker linking and <code>network_mode: service:container</code>)</li> </ol>"},{"location":"advanced-features/linked-containers/#watchtower_depends-on_label","title":"Watchtower Depends-On Label","text":"<p>The <code>com.centurylinklabs.watchtower.depends-on</code> label allows explicit declaration of dependencies:</p> Explicit dependency declaration<pre><code>LABEL com.centurylinklabs.watchtower.depends-on=\"database,redis\"\n</code></pre> <p>This label accepts a comma-separated list of container names that must be available before this container starts.</p>"},{"location":"advanced-features/linked-containers/#docker_compose_depends-on_label","title":"Docker Compose Depends-On Label","text":"<p>Watchtower automatically recognizes Docker Compose's <code>depends_on</code> relationships:</p> Docker Compose dependency<pre><code>services:\n  web:\n    image: nginx\n    depends_on:\n      - database\n  database:\n    image: postgres\n</code></pre> <p>The <code>com.docker.compose.depends_on</code> label is automatically set by Docker Compose and parsed by Watchtower to extract service names.</p>"},{"location":"advanced-features/linked-containers/#docker_links_and_network_mode","title":"Docker Links and Network Mode","text":"<p>For legacy Docker setups using links or <code>network_mode: service:container</code>, Watchtower treats these as implicit dependencies:</p> Legacy Docker linking<pre><code># Container with explicit link\ndocker run --link database:db nginx\n\n# Container using service network mode\ndocker run --network container:database nginx\n</code></pre>"},{"location":"advanced-features/linked-containers/#topological_sorting","title":"Topological Sorting","text":"<p>Watchtower uses topological sorting to determine the correct update order. This algorithm:</p> <ul> <li>Builds a dependency graph from all detected relationships</li> <li>Detects cycles (failing with a circular dependency error)</li> <li>Produces a linear ordering where dependencies precede dependents</li> </ul> <p>Warning</p> <p>Circular dependencies between containers will cause the update process to fail with an error. Ensure your dependency graph is acyclic.</p>"},{"location":"advanced-features/linked-containers/#update_order","title":"Update Order","text":"<p>When updates are needed, Watchtower follows this sequence:</p> <ol> <li>Identify all containers requiring updates</li> <li>Expand the set to include all containers in the dependency chain</li> <li>Sort containers using topological order (dependencies first)</li> <li>Stop containers in reverse topological order (dependents first)</li> <li>Update and restart containers in topological order (dependencies first)</li> </ol> <p>This ensures that:</p> <ul> <li>Dependent services are stopped before their dependencies change</li> <li>Dependencies are fully restarted before dependents attempt to connect</li> </ul>"},{"location":"advanced-features/linked-containers/#configuration","title":"Configuration","text":""},{"location":"advanced-features/linked-containers/#automatic_detection","title":"Automatic Detection","text":"<p>In most cases, no additional configuration is required. Watchtower automatically detects dependencies from:</p> <ul> <li>Docker Compose <code>depends_on</code> declarations</li> <li>Existing Docker links</li> <li><code>network_mode: service:container</code> configurations</li> </ul> <p>Docker Compose Considerations</p> <p>When using Docker Compose, Watchtower leverages <code>depends_on</code> declarations for dependency detection. Dependencies are resolved using service names, not container names. Ensure your <code>depends_on</code> references service names correctly.</p> <p>Rolling restart is currently not supported when used in combination with linked-containers.</p> <p>This limitation exists because linked-containers require coordinated updates across dependency chains, which conflicts with the incremental nature of rolling restarts.</p>"},{"location":"advanced-features/linked-containers/#explicit_dependencies","title":"Explicit Dependencies","text":"<p>For cases where automatic detection is insufficient, use the Watchtower depends-on label:</p> DockerfileDocker Compose <pre><code>FROM nginx:latest\n\n# Declare dependencies on database and cache services\nLABEL com.centurylinklabs.watchtower.depends-on=\"postgres,redis\"\n</code></pre> <pre><code>services:\n  web:\n    image: nginx\n    labels:\n      - com.centurylinklabs.watchtower.depends-on=postgres,redis\n  postgres:\n    image: postgres\n  redis:\n    image: redis\n</code></pre>"},{"location":"advanced-features/linked-containers/#advanced_scenarios","title":"Advanced Scenarios","text":""},{"location":"advanced-features/linked-containers/#multiple_dependencies","title":"Multiple Dependencies","text":"Multiple dependencies<pre><code>LABEL com.centurylinklabs.watchtower.depends-on=\"database,cache,queue\"\n</code></pre>"},{"location":"advanced-features/linked-containers/#complex_dependency_chains","title":"Complex Dependency Chains","text":"Complex dependency chain<pre><code>services:\n  web:\n    image: nginx\n    depends_on:\n      - api\n  api:\n    image: myapi\n    depends_on:\n      - database\n      - cache\n  database:\n    image: postgres\n  cache:\n    image: redis\n</code></pre> <p>In this scenario, Watchtower will update containers in the order: <code>cache</code>, <code>database</code>, <code>api</code>, <code>web</code>.</p>"},{"location":"advanced-features/linked-containers/#examples","title":"Examples","text":""},{"location":"advanced-features/linked-containers/#mysql-wordpress_scenario","title":"MySQL-WordPress Scenario","text":"<p>Consider a classic WordPress setup with MySQL database:</p> Docker ComposeUpdate Process <pre><code>services:\n  wordpress:\n    image: wordpress:latest\n    depends_on:\n      - mysql\n    environment:\n      WORDPRESS_DB_HOST: mysql\n  mysql:\n    image: mysql:8.0\n    environment:\n      MYSQL_ROOT_PASSWORD: example\n</code></pre> <p>When Watchtower detects a MySQL update:</p> <ol> <li>Dependency Detection: Identifies that <code>wordpress</code> depends on <code>mysql</code></li> <li>Stop Order: Stops <code>wordpress</code> first, then <code>mysql</code></li> <li>Update Order: Updates and restarts <code>mysql</code> first, then <code>wordpress</code></li> </ol> <p>This prevents WordPress from losing database connectivity during the update.</p>"},{"location":"advanced-features/linked-containers/#microservices_architecture","title":"Microservices Architecture","text":"<p>For complex applications with multiple services:</p> Docker ComposeDependency Graph <pre><code>services:\n  api-gateway:\n    image: nginx\n    depends_on:\n      - auth-service\n      - user-service\n  auth-service:\n    image: auth-service\n    depends_on:\n      - redis\n  user-service:\n    image: user-service\n    depends_on:\n      - postgres\n  redis:\n    image: redis\n  postgres:\n    image: postgres\n</code></pre> <pre><code>postgres \u2192 user-service\nredis \u2192 auth-service\nauth-service \u2192 api-gateway\nuser-service \u2192 api-gateway\n</code></pre> <p>Update order: <code>postgres</code>, <code>redis</code>, <code>user-service</code>, <code>auth-service</code>, <code>api-gateway</code></p>"},{"location":"advanced-features/linked-containers/#legacy_docker_links","title":"Legacy Docker Links","text":"<p>For applications using traditional Docker linking:</p> Docker Run CommandsWatchtower Behavior <pre><code># Start database\ndocker run -d --name mysql mysql:8.0\n\n# Start web app with link\ndocker run -d --name webapp --link mysql:db nginx\n</code></pre> <p>Watchtower automatically detects the link and ensures <code>webapp</code> is stopped before <code>mysql</code> updates, and <code>mysql</code> restarts before <code>webapp</code>.</p>"},{"location":"advanced-features/linked-containers/#network_mode_dependencies","title":"Network Mode Dependencies","text":"<p>Containers using <code>network_mode: service:container</code>:</p> Docker ComposeWatchtower Behavior <pre><code>services:\n  sidecar:\n    image: sidecar\n    network_mode: service:main-app\n  main-app:\n    image: main-app\n</code></pre> <p>The <code>sidecar</code> container is treated as dependent on <code>main-app</code>, ensuring proper update sequencing.</p>"},{"location":"advanced-features/linked-containers/#troubleshooting","title":"Troubleshooting","text":""},{"location":"advanced-features/linked-containers/#common_issues","title":"Common Issues","text":""},{"location":"advanced-features/linked-containers/#updates_failing_due_to_circular_dependencies","title":"Updates Failing Due to Circular Dependencies","text":"<p>Error</p> <p>If you see \"circular reference detected\" errors, check your dependency declarations for cycles.</p> <p>Solution: Review and remove circular dependencies. For example, if A depends on B and B depends on A, remove one of the dependencies or restructure your services.</p>"},{"location":"advanced-features/linked-containers/#containers_not_updating_in_expected_order","title":"Containers Not Updating in Expected Order","text":"<p>Check:</p> <ul> <li>Verify dependency labels are correctly formatted</li> <li>Ensure container names match exactly</li> <li>Check Docker Compose service names vs container names</li> </ul>"},{"location":"advanced-features/linked-containers/#missing_dependencies","title":"Missing Dependencies","text":"<p>Symptoms: Containers update out of order or fail to connect after updates.</p> <p>Debug: Enable debug logging to see detected dependencies:</p> <pre><code>watchtower --debug\n</code></pre> <p>Look for log messages like:</p> <ul> <li>\"Retrieved links from watchtower depends-on label\"</li> <li>\"Retrieved links from compose depends-on label\"</li> <li>\"Completed dependency sort\"</li> </ul>"},{"location":"advanced-features/linked-containers/#debugging_commands","title":"Debugging Commands","text":"<p>Enable verbose logging to inspect dependency detection:</p> <pre><code>docker run --rm \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  nickfedor/watchtower \\\n  --debug \\\n  --run-once\n</code></pre> <p>Check container labels:</p> <pre><code>docker inspect container_name | jq '.[0].Config.Labels'\n</code></pre>"},{"location":"advanced-features/linked-containers/#best_practices","title":"Best Practices","text":"<ul> <li>Use Docker Compose for complex applications - it provides clear dependency declarations</li> <li>Avoid circular dependencies - they prevent successful updates</li> <li>Test update scenarios in staging environments first</li> <li>Use explicit labels when automatic detection doesn't work</li> <li>Monitor logs during updates to verify correct ordering</li> </ul>"},{"location":"advanced-features/metrics/","title":"Metrics","text":"<p>Experimental feature</p> <p>This feature was added in v1.0.4 and is still considered experimental. If you notice any strange behavior, please raise a ticket in the repository issues.</p> <p>Metrics can be used to track how Watchtower behaves over time.</p> <p>To use this feature, you have to set an API token and enable the metrics API, as well as creating a port mapping for your container for port <code>8080</code>.</p> <p>Note</p> <p>You can enable both the metrics API and the update API simultaneously by using both <code>--http-api-metrics</code> and <code>--http-api-update</code> flags.</p> <p>The metrics API endpoint is <code>/v1/metrics</code> and provides Prometheus-compatible metrics. This is separate from the <code>/v1/update</code> endpoint which triggers updates and returns JSON results.</p>"},{"location":"advanced-features/metrics/#available_metrics","title":"Available Metrics","text":"Name Type Description <code>watchtower_containers_scanned</code> Gauge Number of containers scanned for changes by watchtower during the last scan <code>watchtower_containers_updated</code> Gauge Number of containers updated by watchtower during the last scan <code>watchtower_containers_failed</code> Gauge Number of containers where update failed during the last scan <code>watchtower_containers_restarted_total</code> Counter Total number of containers restarted due to linked dependencies <code>watchtower_scans_total</code> Counter Number of scans since the watchtower started <code>watchtower_scans_skipped</code> Counter Number of skipped scans since watchtower started"},{"location":"advanced-features/metrics/#example_prometheus_scrape_config","title":"Example Prometheus <code>scrape_config</code>","text":"<pre><code>scrape_configs:\n  - job_name: watchtower\n    scrape_interval: 5s\n    metrics_path: /v1/metrics\n    bearer_token: demotoken\n    static_configs:\n      - targets:\n        - 'watchtower:8080'\n</code></pre> <p>Replace <code>demotoken</code> with the Bearer token you have set accordingly.</p>"},{"location":"advanced-features/metrics/#demo","title":"Demo","text":"<p>The repository contains a demo with prometheus and grafana, available through <code>/examples/metrics/docker-compose.yml</code>. This demo is preconfigured with a dashboard, which will look something like this:</p> <p></p>"},{"location":"advanced-features/remote-hosts/","title":"Remote Hosts","text":"<p>By default, Watchtower is set-up to monitor the local Docker daemon (the same daemon running the Watchtower container itself). However, it is possible to configure Watchtower to monitor a remote Docker endpoint. When starting the Watchtower container you can specify a remote Docker endpoint with either the <code>--host</code> flag or the <code>DOCKER_HOST</code> environment variable:</p> <pre><code>docker run -d \\\n  --name watchtower \\\n  nickfedor/watchtower --host \"tcp://10.0.1.2:2375\"\n</code></pre> <p>or</p> <pre><code>docker run -d \\\n  --name watchtower \\\n  -e DOCKER_HOST=\"tcp://10.0.1.2:2375\" \\\n  nickfedor/watchtower\n</code></pre> <p>Note in both of the examples above that it is unnecessary to mount the /var/run/docker.sock into the Watchtower container.</p>"},{"location":"advanced-features/running-multiple-instances/","title":"Running Multiple Instances","text":"<p>By default, Watchtower will clean up other instances within the same scope and won't allow multiple instances running on the same Docker host or swarm. It is possible to override this behavior by defining a scope to each running instance.</p> <p>Note</p> <ul> <li>Multiple instances can't run with the same scope;</li> <li>An instance without a scope will only clean up other unscoped running instances, allowing coexistence with scoped instances;</li> <li>Supplying <code>none</code> as the scope will treat <code>com.centurylinklabs.watchtower.scope=none</code>, <code>com.centurylinklabs.watchtower.scope=</code> and the lack of a <code>com.centurylinklabs.watchtower.scope</code> label as the scope <code>none</code>. This enables you to run both scoped and unscoped watchtower instances on the same machine.</li> </ul> <p>To define an instance monitoring scope, use the <code>--scope</code> argument or the <code>WATCHTOWER_SCOPE</code> environment variable on startup and set the <code>com.centurylinklabs.watchtower.scope</code> label with the same value for the containers you want to include in this instance's scope (including the instance itself).</p> <p>For example, in a Docker Compose config file:</p> <pre><code>version: '3'\n\nservices:\n  app-with-scope:\n    image: myapps/monitored-by-watchtower\n    labels: [ \"com.centurylinklabs.watchtower.scope=myscope\" ]\n\n  scoped-watchtower:\n    image: nickfedor/watchtower\n    volumes: [ \"/var/run/docker.sock:/var/run/docker.sock\" ]\n    command: --interval 30 --scope myscope\n    labels: [ \"com.centurylinklabs.watchtower.scope=myscope\" ]\n\n  unscoped-app-a:\n    image: myapps/app-a\n\n  unscoped-app-b:\n    image: myapps/app-b\n    labels: [ \"com.centurylinklabs.watchtower.scope=none\" ]\n\n  unscoped-app-c:\n    image: myapps/app-b\n    labels: [ \"com.centurylinklabs.watchtower.scope=\" ]\n\n  unscoped-watchtower:\n    image: nickfedor/watchtower\n    volumes: [ \"/var/run/docker.sock:/var/run/docker.sock\" ]\n    command: --interval 30 --scope none\n</code></pre>"},{"location":"advanced-features/stop-signals/","title":"Stop Signals","text":"<p>When Watchtower detects that a running container needs to be updated it will stop the container by sending it a SIGTERM signal. If your container should be shutdown with a different signal you can communicate this to Watchtower by setting a label named com.centurylinklabs.watchtower.stop-signal with the value of the desired signal.</p> <p>This label can be coded directly into your image by using the <code>LABEL</code> instruction in your Dockerfile:</p> <pre><code>LABEL com.centurylinklabs.watchtower.stop-signal=\"SIGHUP\"\n</code></pre> <p>Or, it can be specified as part of the <code>docker run</code> command line:</p> <pre><code>docker run -d --label=com.centurylinklabs.watchtower.stop-signal=SIGHUP someimage\n</code></pre>"},{"location":"configuration/arguments/","title":"Arguments","text":""},{"location":"configuration/arguments/#overview","title":"Overview","text":"<p>By default, Watchtower monitors all containers running on the Docker daemon it connects to (typically the local daemon, configurable via the <code>--host</code> flag). To limit monitoring to specific containers, provide their names as arguments when starting Watchtower.</p> <pre><code>docker run -d \\\n    --name watchtower \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    --restart unless-stopped \\\n    nickfedor/watchtower \\\n    nginx redis\n</code></pre> <p>In this example, Watchtower monitors only the \"nginx\" and \"redis\" containers, ignoring others. To run a single update attempt and exit, use the <code>--run-once</code> flag with the <code>--rm</code> option to remove the Watchtower container afterward.</p> <pre><code>docker run --rm \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    nickfedor/watchtower \\\n    --run-once \\\n    nginx redis\n</code></pre> <p>This command triggers an update attempt for \"nginx\" and \"redis\" containers, displays debug output, and removes the Watchtower container upon completion. Without arguments, Watchtower monitors all running containers.</p>"},{"location":"configuration/arguments/#secretsfiles","title":"Secrets/Files","text":"<p>Certain flags support referencing a file, using its contents as the value, to securely handle sensitive data like passwords or tokens, avoiding exposure in configuration files or command lines.</p> Flag Environment Variable <code>--http-api-token</code> <code>WATCHTOWER_HTTP_API_TOKEN</code> <code>--notification-email-server-password</code> <code>WATCHTOWER_NOTIFICATION_EMAIL_SERVER_PASSWORD</code> <code>--notification-gotify-token</code> <code>WATCHTOWER_NOTIFICATION_GOTIFY_TOKEN</code> <code>--notification-msteams-hook</code> <code>WATCHTOWER_NOTIFICATION_MSTEAMS_HOOK</code> <code>--notification-slack-hook-url</code> <code>WATCHTOWER_NOTIFICATION_SLACK_HOOK_URL</code> <code>--notification-url</code> <code>WATCHTOWER_NOTIFICATION_URL</code>"},{"location":"configuration/arguments/#example_docker_compose_usage","title":"Example Docker Compose Usage","text":"<pre><code>secrets:\n  access_token:\n    file: access_token\n\nservices:\n  watchtower:\n    secrets:\n      - access_token\n    environment:\n      - WATCHTOWER_HTTP_API_TOKEN=/run/secrets/access_token\n</code></pre>"},{"location":"configuration/arguments/#time_zone","title":"Time Zone","text":"<p>Sets the time zone for Watchtower's logs and the <code>--schedule</code> flag's cron expressions. Without this setting, Watchtower defaults to UTC.</p> <p>To specify a time zone, use a value from the TZ Database (e.g., <code>Europe/Rome</code>). Alternatively, mount the host's <code>/etc/localtime</code> file using <code>-v /etc/localtime:/etc/localtime:ro</code>.</p> <pre><code>            Argument: None\nEnvironment Variable: TZ\n                Type: String\n             Default: UTC\n</code></pre>"},{"location":"configuration/arguments/#general_options","title":"General Options","text":""},{"location":"configuration/arguments/#help","title":"Help","text":"<p>Displays documentation for supported flags.</p> <pre><code>            Argument: --help\nEnvironment Variable: N/A\n                Type: N/A\n             Default: N/A\n</code></pre>"},{"location":"configuration/arguments/#debug","title":"Debug","text":"<p>Enables debug mode with verbose logging.</p> <pre><code>            Argument: --debug, -d\nEnvironment Variable: WATCHTOWER_DEBUG\n                Type: Boolean\n             Default: false\n</code></pre> <p>Note</p> <p>Equivalent to <code>--log-level debug</code>. As an argument, it does not accept a value (e.g., <code>--debug true</code> is invalid).</p> <p>See Maximum Log Level.</p>"},{"location":"configuration/arguments/#trace","title":"Trace","text":"<p>Enables trace mode with highly verbose logging, including sensitive information like credentials.</p> <pre><code>            Argument: --trace\nEnvironment Variable: WATCHTOWER_TRACE\n                Type: Boolean\n             Default: false\n</code></pre> <p>Note</p> <p>Equivalent to <code>--log-level trace</code>. As an argument, does not accept a value (e.g., <code>--trace true</code> is invalid).</p> <p>See Maximum Log Level.</p> <p>Warning</p> <p>Use with caution due to credential exposure.</p>"},{"location":"configuration/arguments/#maximum_log_level","title":"Maximum Log Level","text":"<p>Sets the maximum log level output to STDERR, visible in <code>docker logs</code> when running Watchtower in a container.</p> <pre><code>            Argument: --log-level\nEnvironment Variable: WATCHTOWER_LOG_LEVEL\n     Possible Values: panic, fatal, error, warn, info, debug, trace\n             Default: info\n</code></pre>"},{"location":"configuration/arguments/#logging_format","title":"Logging Format","text":"<p>Specifies the format for console log output.</p> <pre><code>            Argument: --log-format, -l\nEnvironment Variable: WATCHTOWER_LOG_FORMAT\n     Possible Values: Auto, LogFmt, Pretty, JSON\n             Default: Auto\n</code></pre>"},{"location":"configuration/arguments/#disable_ansi_colors","title":"Disable ANSI Colors","text":"<p>Disables ANSI color escape codes in log output for plain text logs.</p> <pre><code>            Argument: --no-color\nEnvironment Variable: NO_COLOR\n                Type: Boolean\n             Default: false\n</code></pre>"},{"location":"configuration/arguments/#run_once","title":"Run Once","text":"<p>Triggers a single update attempt for specified containers and exits immediately.</p> <pre><code>            Argument: --run-once, -R\nEnvironment Variable: WATCHTOWER_RUN_ONCE\n                Type: Boolean\n             Default: false\n</code></pre> <p>Watchtower automatically sets its own restart policy to \"no\" in run-once mode to prevent unwanted restarts.</p> <p>Use with <code>--rm</code> to remove the Watchtower container after completion.</p>"},{"location":"configuration/arguments/#update_on_start","title":"Update on Start","text":"<p>Performs an update check on startup. If a schedule is configured (via --schedule or --interval), then Watchtower continues with periodic updates.</p> <pre><code>            Argument: --update-on-start\nEnvironment Variable: WATCHTOWER_UPDATE_ON_START\n                Type: Boolean\n             Default: false\n</code></pre> <p>Note</p> <p>If used with <code>--run-once</code>, a warning is logged and <code>--run-once</code> takes precedence.</p>"},{"location":"configuration/arguments/#scheduling_polling","title":"Scheduling &amp; Polling","text":""},{"location":"configuration/arguments/#schedule","title":"Schedule","text":"<p>Defines when and how often Watchtower checks for new images using a 6-field Cron expression.</p> <p>Example: <code>--schedule \"0 0 4 * * *\"</code> runs daily at 4 AM.</p> <pre><code>            Argument: --schedule, -s\nEnvironment Variable: WATCHTOWER_SCHEDULE\n                Type: String\n             Default: None\n</code></pre> <p>Note</p> <p>Cannot be used with <code>--interval</code>.</p> <p>Requires a time zone set via <code>TZ</code> or a mounted <code>/etc/localtime</code> file. See Time Zone.</p>"},{"location":"configuration/arguments/#poll_interval","title":"Poll Interval","text":"<p>Sets the interval (in seconds) for polling new images.</p> <pre><code>            Argument: --interval, -i\nEnvironment Variable: WATCHTOWER_POLL_INTERVAL\n                Type: Integer\n             Default: 86400 (24 hours)\n</code></pre> <p>Note</p> <p>Cannot be used with <code>--schedule</code>. Overrides cron-based scheduling.</p>"},{"location":"configuration/arguments/#http_api_periodic_polls","title":"HTTP API Periodic Polls","text":"<p>Enables periodic updates when HTTP API mode is active, allowing both API-triggered and scheduled updates.</p> <pre><code>            Argument: --http-api-periodic-polls\nEnvironment Variable: WATCHTOWER_HTTP_API_PERIODIC_POLLS\n                Type: Boolean\n             Default: false\n</code></pre> <p>Note</p> <p>Requires <code>--http-api-update</code>.</p> <p>See HTTP API Mode.</p>"},{"location":"configuration/arguments/#container_management","title":"Container Management","text":""},{"location":"configuration/arguments/#include_stopped_containers","title":"Include Stopped Containers","text":"<p>Includes created and exited containers in monitoring and updates.</p> <pre><code>            Argument: --include-stopped, -S\nEnvironment Variable: WATCHTOWER_INCLUDE_STOPPED\n                Type: Boolean\n             Default: false\n</code></pre>"},{"location":"configuration/arguments/#revive_stopped_containers","title":"Revive Stopped Containers","text":"<p>Restarts stopped containers after their images are updated.</p> <pre><code>            Argument: --revive-stopped\nEnvironment Variable: WATCHTOWER_REVIVE_STOPPED\n                Type: Boolean\n             Default: false\n</code></pre> <p>Note</p> <p>Requires <code>--include-stopped</code>.</p>"},{"location":"configuration/arguments/#include_restarting_containers","title":"Include Restarting Containers","text":"<p>Includes containers in the restarting state for monitoring and updates.</p> <pre><code>            Argument: --include-restarting\nEnvironment Variable: WATCHTOWER_INCLUDE_RESTARTING\n                Type: Boolean\n             Default: false\n</code></pre>"},{"location":"configuration/arguments/#disable_container_restart","title":"Disable Container Restart","text":"<p>Prevents restarting containers after updating. This is useful when an external system (e.g., systemd) manages the container lifecycle.</p> <pre><code>            Argument: --no-restart\nEnvironment Variable: WATCHTOWER_NO_RESTART\n                Type: Boolean\n             Default: false\n</code></pre> <p>Warning</p> <p>Combining <code>--no-restart</code> with <code>--cleanup</code> during Watchtower self-update may leave a renamed Watchtower container running without starting a new one, preventing cleanup of the old image.</p> <p>Use cautiously for self-updating Watchtower instances and consider external lifecycle management (e.g., Docker Compose) to restart containers manually.</p>"},{"location":"configuration/arguments/#rolling_restart","title":"Rolling Restart","text":"<p>Restarts containers one at a time to minimize downtime. This is ideal for zero-downtime deployments with lifecycle hooks. When containers have health checks configured, Watchtower waits for each container to become healthy before proceeding to the next one.</p> <pre><code>            Argument: --rolling-restart\nEnvironment Variable: WATCHTOWER_ROLLING_RESTART\n                Type: Boolean\n             Default: false\n</code></pre> <p>Note</p> <p>When combined with <code>--cleanup</code>, image cleanup is deferred until all containers are updated, which may temporarily increase disk usage for large numbers of containers (&gt;50). This is typically negligible for homelab setups but monitor disk space on resource-constrained hosts.</p> <p>If a container fails to become healthy within 5 minutes, Watchtower logs a warning but continues with the next container to avoid blocking the entire update process.</p> <p>This functionality is currently not supported when used in combination with linked-containers.</p> <p>This limitation exists because linked-containers require coordinated updates across dependency chains, which conflicts with the incremental nature of rolling restarts.</p>"},{"location":"configuration/arguments/#cleanup_old_images","title":"Cleanup Old Images","text":"<p>Removes old images after updating containers to free disk space.</p> <pre><code>            Argument: --cleanup\nEnvironment Variable: WATCHTOWER_CLEANUP\n                Type: Boolean\n             Default: false\n</code></pre> <p>Note</p> <p>During Watchtower self-updates, cleanup is deferred to the new container to prevent premature image deletion.</p> <p>Ensure <code>--no-restart</code> is not used with <code>--cleanup</code> to avoid incomplete updates.</p>"},{"location":"configuration/arguments/#remove_anonymous_volumes","title":"Remove Anonymous Volumes","text":"<p>Deletes anonymous volumes when updating containers. Named volumes remain unaffected.</p> <pre><code>            Argument: --remove-volumes\nEnvironment Variable: WATCHTOWER_REMOVE_VOLUMES\n                Type: Boolean\n             Default: false\n</code></pre> <p>Note</p> <p>Containers with the Docker <code>AutoRemove</code> option enabled are automatically removed by the Docker daemon after stopping. Watchtower skips explicit removal in such cases. This does not affect named volumes.</p>"},{"location":"configuration/arguments/#monitor_only","title":"Monitor Only","text":"<p>Monitors for new images, sends notifications, and runs lifecycle hooks without updating containers.</p> <pre><code>            Argument: --monitor-only\nEnvironment Variable: WATCHTOWER_MONITOR_ONLY\n                Type: Boolean\n             Default: false\n</code></pre> <p>Note</p> <p>Images may still be pulled due to Docker API limitations for digest comparison.</p> <p>Can be set per container via the <code>com.centurylinklabs.watchtower.monitor-only</code> label.</p> <p>See Label Precedence.</p>"},{"location":"configuration/arguments/#disable_image_pulling","title":"Disable Image Pulling","text":"<p>Prevents pulling new images from registries, monitoring only local image cache changes. Useful for locally built images.</p> <pre><code>            Argument: --no-pull\nEnvironment Variable: WATCHTOWER_NO_PULL\n                Type: Boolean\n             Default: false\n</code></pre> <p>Note</p> <p>Can be set per container via the <code>com.centurylinklabs.watchtower.no-pull</code> label.</p> <p>See Label Precedence.</p>"},{"location":"configuration/arguments/#enable_label_filter","title":"Enable Label Filter","text":"<p>Restricts monitoring to containers with the <code>com.centurylinklabs.watchtower.enable</code> label set to <code>true</code> when the <code>--label-enable</code> flag is specified. Without <code>--label-enable</code>, containers with this label set to <code>false</code> are excluded, while others are monitored by default.</p> <pre><code>            Argument: --label-enable\nEnvironment Variable: WATCHTOWER_LABEL_ENABLE\n                Type: Boolean\n             Default: false\n</code></pre> <p>Note</p> <p>When <code>--label-enable</code> is unset, containers without the <code>com.centurylinklabs.watchtower.enable</code> label or with it set to <code>true</code> are monitored, and those with <code>false</code> are excluded.</p> <p>When <code>--label-enable</code> is set, only containers with <code>true</code> are monitored, ignoring those with <code>false</code> or no label.</p>"},{"location":"configuration/arguments/#disable_specific_containers","title":"Disable Specific Containers","text":"<p>Excludes containers by name from monitoring, even if they have the enable label set to <code>true</code>.</p> <pre><code>            Argument: --disable-containers, -x\nEnvironment Variable: WATCHTOWER_DISABLE_CONTAINERS\n                Type: Comma- or space-separated string list\n             Default: None\n</code></pre>"},{"location":"configuration/arguments/#scope_filter","title":"Scope Filter","text":"<p>Monitors containers with a <code>com.centurylinklabs.watchtower.scope</code> label matching the specified value, enabling multiple Watchtower instances.</p> <pre><code>            Argument: --scope\nEnvironment Variable: WATCHTOWER_SCOPE\n                Type: String\n             Default: None\n</code></pre> <p>Note</p> <p>Set to <code>none</code> to ignore scoped containers. Without this flag, Watchtower monitors all containers regardless of scope.</p> <p>For self-updates, ensure all Watchtower containers share the same <code>com.centurylinklabs.watchtower.scope</code> label to guarantee cleanup of renamed containers and old images. Mismatched labels may prevent detection, leaving resources running.</p> <p>See Running Multiple Instances.</p>"},{"location":"configuration/arguments/#label_precedence","title":"Label Precedence","text":"<p>Allows container labels (e.g., <code>com.centurylinklabs.watchtower.monitor-only</code>, <code>com.centurylinklabs.watchtower.no-pull</code>) to override corresponding flags.</p> <pre><code>            Argument: --label-take-precedence\nEnvironment Variable: WATCHTOWER_LABEL_TAKE_PRECEDENCE\n                Type: Boolean\n             Default: false\n</code></pre>"},{"location":"configuration/arguments/#registry_authentication","title":"Registry &amp; Authentication","text":""},{"location":"configuration/arguments/#repo_user","title":"REPO_USER","text":"<p>Sets the username for authenticating with a private registry, such as Docker Hub.</p> <pre><code>            Argument: None\nEnvironment Variable: REPO_USER\n                Type: String\n             Default: None\n</code></pre> <p>Note</p> <p>Must be used with <code>REPO_PASS</code> to provide valid credentials. Suitable for simple username/password authentication.</p> <p>For Docker Hub, the registry is implicitly <code>https://index.docker.io/v1/</code>.</p>"},{"location":"configuration/arguments/#repo_pass","title":"REPO_PASS","text":"<p>Sets the password for authenticating with a private registry, such as Docker Hub.</p> <pre><code>            Argument: None\nEnvironment Variable: REPO_PASS\n                Type: String\n             Default: None\n</code></pre> <p>Note</p> <p>Must be used with <code>REPO_USER</code>.</p> <p>Can be a password or a personal access token for registries requiring 2FA (e.g., Docker Hub).</p> <p>Use Docker secrets (e.g., <code>WATCHTOWER_PASS=/run/secrets/repo_pass</code>) or environment files to avoid exposing sensitive data in command lines.</p>"},{"location":"configuration/arguments/#docker_config","title":"DOCKER_CONFIG","text":"<p>Specifies the directory containing the Docker configuration file (<code>config.json</code>) for registry authentication.</p> <pre><code>            Argument: None\nEnvironment Variable: DOCKER_CONFIG\n                Type: String\n             Default: `/`\n</code></pre> <p>Note</p> <p>Useful for registries requiring complex authentication (e.g., 2FA on Docker Hub) or credential helpers (e.g., AWS ECR).</p> <p>Mount the <code>config.json</code> file to the container (e.g., <code>-v ~/.docker/config.json:/config.json</code>) and set this variable to the directory containing the file (e.g., <code>/</code>).</p> <p>Changes to the mounted file may require a symlink to ensure updates propagate.</p> <p>See Usage and Private Registries.</p>"},{"location":"configuration/arguments/#skip_registry_tls_verification","title":"Skip Registry TLS Verification","text":"<p>Disables TLS certificate verification for registry connections, useful for self-signed certificates or insecure registries.</p> <pre><code>            Argument: --registry-tls-skip\nEnvironment Variable: WATCHTOWER_REGISTRY_TLS_SKIP\n                Type: Boolean\n             Default: false\n</code></pre> <p>Warning</p> <p>Use cautiously, as it reduces security. Suitable for testing or private registries.</p>"},{"location":"configuration/arguments/#minimum_registry_tls_version","title":"Minimum Registry TLS Version","text":"<p>Sets the minimum TLS version for registry connections, overriding the default (TLS 1.2).</p> <pre><code>            Argument: --registry-tls-min-version\nEnvironment Variable: WATCHTOWER_REGISTRY_TLS_MIN_VERSION\n     Possible Values: TLS1.0, TLS1.1, TLS1.2, TLS1.3\n             Default: TLS1.2\n</code></pre> <p>Warning</p> <p>Using older versions of TLS not recommended for security reasons.</p>"},{"location":"configuration/arguments/#proxy_configuration","title":"Proxy Configuration","text":"<p>Watchtower supports HTTP/HTTPS proxies for registry connections by respecting standard environment variables. Set these in the Watchtower container to route requests (e.g., to Docker Hub or private registries) through a proxy. This is useful in environments without direct internet access.</p> <p>Proxy settings are read from the following variables (uppercase and lowercase variants are supported for compatibility):</p> <pre><code>            Argument: None\nEnvironment Variable: HTTP_PROXY / http_proxy\n                Type: String (e.g., \"http://proxy.example.com:3128\")\n             Default: None\n</code></pre> <pre><code>            Argument: None\nEnvironment Variable: HTTPS_PROXY / https_proxy\n                Type: String (e.g., \"http://proxy.example.com:3128\")\n             Default: None\n</code></pre> <pre><code>            Argument: None\nEnvironment Variable: NO_PROXY / no_proxy\n                Type: Comma-separated string (e.g., \"localhost,127.0.0.1,internal.example.com\")\n             Default: None\n</code></pre> <p>Note</p> <p>Proxies may require authentication. Include it in the URL (e.g., <code>http://user:pass@proxy.example.com:3128</code>), but avoid exposing credentials in the command line by using Docker secrets or environment files instead.</p> <p>If your proxy uses a self-signed certificate, combine with <code>--registry-tls-skip</code> to disable TLS verification (use cautiously).</p> <p>For details on how Go handles these variables, see the net/http.ProxyFromEnvironment documentation.</p>"},{"location":"configuration/arguments/#warn_on_head_failure","title":"Warn on HEAD Failure","text":"<p>Controls warnings for failed HEAD requests to registries. <code>Auto</code> warns for registries known to support HEAD requests (e.g., docker.io) that may rate-limit.</p> <pre><code>            Argument: --warn-on-head-failure\nEnvironment Variable: WATCHTOWER_WARN_ON_HEAD_FAILURE\n     Possible Values: always, auto, never\n             Default: auto\n</code></pre>"},{"location":"configuration/arguments/#docker_connection","title":"Docker Connection","text":""},{"location":"configuration/arguments/#docker_host","title":"Docker Host","text":"<p>Specifies the Docker daemon socket to connect to, supporting remote hosts via TCP (e.g., <code>tcp://hostname:port</code>).</p> <pre><code>            Argument: --host, -H\nEnvironment Variable: DOCKER_HOST\n                Type: String\n             Default: unix:///var/run/docker.sock\n</code></pre>"},{"location":"configuration/arguments/#docker_api_version","title":"Docker API Version","text":"<p>Sets the Docker API version for client-daemon communication.</p> <pre><code>            Argument: --api-version, -a\nEnvironment Variable: DOCKER_API_VERSION\n                Type: String\n             Default: Autonegotiated\n</code></pre> <p>Note</p> <p>Falls back to autonegotiation on failure.</p> <p>Warning</p> <p>Minimum supported version is Docker v1.23.</p> <p>Refer to Docker's API version matrix for compatibility.</p>"},{"location":"configuration/arguments/#enable_docker_tls_verification","title":"Enable Docker TLS Verification","text":"<p>Enables TLS verification for Docker socket connections.</p> <pre><code>            Argument: --tlsverify\nEnvironment Variable: DOCKER_TLS_VERIFY\n                Type: Boolean\n             Default: false\n</code></pre>"},{"location":"configuration/arguments/#disable_memory_swappiness","title":"Disable Memory Swappiness","text":"<p>Sets memory swappiness to <code>nil</code> for Podman compatibility with crun and cgroupv2, overriding Podman's default of <code>0</code>.</p> <pre><code>            Argument: --disable-memory-swappiness\nEnvironment Variable: WATCHTOWER_DISABLE_MEMORY_SWAPPINESS\n                Type: Boolean\n             Default: false\n</code></pre>"},{"location":"configuration/arguments/#cpu_copy_mode","title":"CPU Copy Mode","text":"<p>Controls how CPU settings are copied when recreating containers, addressing Podman compatibility issues with CPU limits. Podman handles NanoCPUs differently than Docker, which can cause container recreation failures.</p> <pre><code>            Argument: --cpu-copy-mode\nEnvironment Variable: WATCHTOWER_CPU_COPY_MODE\n                Type: String\n     Possible Values: auto, full, none\n             Default: auto\n</code></pre> <p>Note</p> <ul> <li>auto: Automatically detects if running on Podman and filters NanoCPUs for compatibility. On Docker, copies all CPU settings.</li> <li>full: Copies all CPU settings unchanged (original behavior).</li> <li>none: Strips all CPU limits to avoid compatibility issues.</li> </ul> <p>Use <code>auto</code> in mixed Docker/Podman environments. Use <code>full</code> if running only on Docker and want to preserve all CPU limits. Use <code>none</code> if CPU limits are causing issues and you prefer no limits on recreated containers.</p>"},{"location":"configuration/arguments/#usage_examples","title":"Usage Examples","text":"<p>Run Watchtower with automatic CPU compatibility:</p> <pre><code>docker run -d \\\n    --name watchtower \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    nickfedor/watchtower \\\n    --cpu-copy-mode auto\n</code></pre> <p>Force full CPU copying (Docker-only environments):</p> <pre><code>docker run -d \\\n    --name watchtower \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    nickfedor/watchtower \\\n    --cpu-copy-mode full\n</code></pre> <p>Strip all CPU limits:</p> <pre><code>docker run -d \\\n    --name watchtower \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    nickfedor/watchtower \\\n    --cpu-copy-mode none\n</code></pre>"},{"location":"configuration/arguments/#http_api_metrics","title":"HTTP API &amp; Metrics","text":""},{"location":"configuration/arguments/#http_api_mode","title":"HTTP API Mode","text":"<p>Runs Watchtower in HTTP API mode, allowing updates only via HTTP requests, with support for tag-specific filtering (e.g., <code>image=foo/bar:1.0</code>).</p> <pre><code>            Argument: --http-api-update\nEnvironment Variable: WATCHTOWER_HTTP_API_UPDATE\n                Type: Boolean\n             Default: false\n</code></pre> <p>Note</p> <p>See HTTP API Mode for details.</p>"},{"location":"configuration/arguments/#http_api_token","title":"HTTP API Token","text":"<p>Sets an authentication token for HTTP API requests. Can reference a file for security.</p> <pre><code>            Argument: --http-api-token\nEnvironment Variable: WATCHTOWER_HTTP_API_TOKEN\n                Type: String\n             Default: None\n</code></pre>"},{"location":"configuration/arguments/#http_api_metrics_1","title":"HTTP API Metrics","text":"<p>Enables a Prometheus metrics endpoint via HTTP.</p> <pre><code>            Argument: --http-api-metrics\nEnvironment Variable: WATCHTOWER_HTTP_API_METRICS\n                Type: Boolean\n             Default: false\n</code></pre> <p>Note</p> <p>See Metrics for details.</p>"},{"location":"configuration/arguments/#http_api_host","title":"HTTP API Host","text":"<p>Sets the host to bind the HTTP API to.</p> <pre><code>            Argument: --http-api-host\nEnvironment Variable: WATCHTOWER_HTTP_API_HOST\n                Type: String\n             Default: empty (binds to all interfaces)\n</code></pre> <p>Note</p> <p>If not specified, Watchtower listens on all interfaces on the port specified by <code>--http-api-port</code>.  Use this option to bind to a specific host, such as <code>127.0.0.1</code> for localhost only.  The host must be a valid IP address (IPv4 or IPv6).  The port is set separately with <code>--http-api-port</code>.</p>"},{"location":"configuration/arguments/#http_api_port","title":"HTTP API Port","text":"<p>Sets the listening port for the HTTP API.</p> <pre><code>            Argument: --http-api-port\nEnvironment Variable: WATCHTOWER_HTTP_API_PORT\n                Type: String\n             Default: 8080\n</code></pre>"},{"location":"configuration/arguments/#notifications","title":"Notifications","text":""},{"location":"configuration/arguments/#notification_url","title":"Notification URL","text":"<p>Configures the notification service URL. Can reference a file for sensitive values.</p> <pre><code>             Argument: --notification-url\nEnvironment Variable: WATCHTOWER_NOTIFICATION_URL\n                 Type: String\n              Default: None\n</code></pre>"},{"location":"configuration/arguments/#notification_split_by_container","title":"Notification Split by Container","text":"<p>Send separate notifications for each updated container instead of grouping them.</p> <pre><code>            Argument: --notification-split-by-container\nEnvironment Variable: WATCHTOWER_NOTIFICATION_SPLIT_BY_CONTAINER\n                Type: Boolean\n             Default: false\n</code></pre> <p>Note</p> <p>When disabled (default), notifications are grouped for all updated containers in a single session. When enabled, a separate notification is sent for each container update.</p>"},{"location":"configuration/arguments/#notification_email_server_password","title":"Notification Email Server Password","text":"<p>Sets the password for the email notification server. Can reference a file for security.</p> <pre><code>            Argument: --notification-email-server-password\nEnvironment Variable: WATCHTOWER_NOTIFICATION_EMAIL_SERVER_PASSWORD\n                Type: String\n             Default: None\n</code></pre>"},{"location":"configuration/arguments/#notification_slack_hook_url","title":"Notification Slack Hook URL","text":"<p>Sets the Slack webhook URL for notifications. Can reference a file for security.</p> <pre><code>            Argument: --notification-slack-hook-url\nEnvironment Variable: WATCHTOWER_NOTIFICATION_SLACK_HOOK_URL\n                Type: String\n             Default: None\n</code></pre>"},{"location":"configuration/arguments/#notification_microsoft_teams_hook","title":"Notification Microsoft Teams Hook","text":"<p>Sets the Microsoft Teams webhook URL for notifications. Can reference a file for security.</p> <pre><code>            Argument: --notification-msteams-hook\nEnvironment Variable: WATCHTOWER_NOTIFICATION_MSTEAMS_HOOK\n                Type: String\n             Default: None\n</code></pre>"},{"location":"configuration/arguments/#notification_gotify_token","title":"Notification Gotify Token","text":"<p>Sets the Gotify token for notifications. Can reference a file for security.</p> <pre><code>            Argument: --notification-gotify-token\nEnvironment Variable: WATCHTOWER_NOTIFICATION_GOTIFY_TOKEN\n                Type: String\n             Default: None\n</code></pre>"},{"location":"configuration/arguments/#disable_startup_message","title":"Disable Startup Message","text":"<p>Suppresses the info-level notification sent when Watchtower starts.</p> <pre><code>            Argument: --no-startup-message\nEnvironment Variable: WATCHTOWER_NO_STARTUP_MESSAGE\n                Type: Boolean\n             Default: false\n</code></pre>"},{"location":"configuration/arguments/#lifecycle_health","title":"Lifecycle &amp; Health","text":""},{"location":"configuration/arguments/#container_stop_timeout","title":"Container Stop Timeout","text":"<p>Sets the timeout (e.g., <code>30s</code>) before forcibly stopping a container during updates.</p> <pre><code>            Argument: --stop-timeout\nEnvironment Variable: WATCHTOWER_TIMEOUT\n                Type: Duration\n              Default: 30s\n</code></pre>"},{"location":"configuration/arguments/#lifecycle_uid","title":"Lifecycle UID","text":"<p>Sets the default user ID to run lifecycle hooks as when no container-specific UID is specified.</p> <pre><code>            Argument: --lifecycle-uid\nEnvironment Variable: WATCHTOWER_LIFECYCLE_UID\n                Type: Integer\n              Default: None\n</code></pre> <p>Note</p> <p>Container-specific labels (<code>com.centurylinklabs.watchtower.lifecycle.uid</code>) take precedence over this global setting.</p> <p>See Lifecycle Hooks.</p>"},{"location":"configuration/arguments/#lifecycle_gid","title":"Lifecycle GID","text":"<p>Sets the default group ID to run lifecycle hooks as when no container-specific GID is specified.</p> <pre><code>            Argument: --lifecycle-gid\nEnvironment Variable: WATCHTOWER_LIFECYCLE_GID\n                Type: Integer\n              Default: None\n</code></pre> <p>Note</p> <p>Container-specific labels (<code>com.centurylinklabs.watchtower.lifecycle.gid</code>) take precedence over this global setting.</p> <p>See Lifecycle Hooks.</p>"},{"location":"configuration/arguments/#health_check","title":"Health Check","text":"<p>Returns a success exit code for Docker <code>HEALTHCHECK</code>, verifying another process is running in the container.</p> <pre><code>            Argument: --health-check\nEnvironment Variable: None\n                Type: N/A\n             Default: N/A\n</code></pre> <p>Note</p> <p>Intended solely for Docker <code>HEALTHCHECK</code>. Do not use on the main command line.</p>"},{"location":"configuration/arguments/#output_compatibility","title":"Output &amp; Compatibility","text":""},{"location":"configuration/arguments/#programmatic_output_porcelain","title":"Programmatic Output (Porcelain)","text":"<p>Outputs session results in a machine-readable format (version specified by <code>VERSION</code>).</p> <pre><code>            Argument: --porcelain, -P\nEnvironment Variable: WATCHTOWER_PORCELAIN\n     Possible Values: v1\n             Default: None\n</code></pre> <p>Note</p> <p>Equivalent to: <pre><code>--notification-url logger://\n--notification-log-stdout\n--notification-report\n--notification-template porcelain.VERSION.summary-no-log\n</code></pre></p>"},{"location":"configuration/container-selection/","title":"Container Selection","text":"<p>By default, Watchtower will watch all containers. However, sometimes only some containers should be updated.</p> <p>There are two options:</p> <ul> <li>Fully exclude: You can choose to exclude containers entirely from being watched by Watchtower.</li> <li>Monitor only: In this mode, Watchtower checks for container updates, sends notifications and invokes the pre-check/post-check hooks on the containers but does not perform the update.</li> </ul>"},{"location":"configuration/container-selection/#full_exclude","title":"Full Exclude","text":"<p>If you need to exclude some containers, set the com.centurylinklabs.watchtower.enable label to <code>false</code>. For clarity this should be set on the container(s) you wish to be ignored, this is not set on Watchtower.</p> dockerfiledocker rundocker-compose <pre><code>LABEL com.centurylinklabs.watchtower.enable=\"false\"\n</code></pre> <pre><code>docker run -d --label=com.centurylinklabs.watchtower.enable=false someimage\n</code></pre> <pre><code>version: \"3\"\nservices:\n  someimage:\n    container_name: someimage\n    labels:\n      - \"com.centurylinklabs.watchtower.enable=false\"\n</code></pre> <p>If instead you want to only include containers with the enable label, pass the <code>--label-enable</code> flag or the <code>WATCHTOWER_LABEL_ENABLE</code> environment variable on startup for Watchtower and set the com.centurylinklabs.watchtower.enable label with a value of <code>true</code> on the containers you want to watch.</p> dockerfiledocker rundocker-compose <pre><code>LABEL com.centurylinklabs.watchtower.enable=\"true\"\n</code></pre> <pre><code>docker run -d --label=com.centurylinklabs.watchtower.enable=true someimage\n</code></pre> <pre><code>version: \"3\"\nservices:\n  someimage:\n    container_name: someimage\n    labels:\n      - \"com.centurylinklabs.watchtower.enable=true\"\n</code></pre> <p>If you wish to create a monitoring scope, you will need to run multiple instances and set a scope for each of them.</p> <p>Watchtower filters running containers by testing them against each configured criteria. A container is monitored if all criteria are met.</p> <p>For example:</p> <ul> <li>If a container's name is on the monitoring name list (not empty <code>--name</code> argument), but it is not enabled (centurylinklabs.watchtower.enable=false), then it won't be monitored.</li> <li>If a container's name is not on the monitoring name list (not empty <code>--name</code> argument), even if it is enabled (centurylinklabs.watchtower.enable=true and <code>--label-enable</code> flag is set), then it won't be monitored.</li> </ul>"},{"location":"configuration/container-selection/#monitor_only","title":"Monitor Only","text":"<p>Individual containers can be marked to only be monitored and will not be updated by Watchtower.</p> <p>To do so, set the com.centurylinklabs.watchtower.monitor-only label to <code>true</code> on that container:</p> <pre><code>LABEL com.centurylinklabs.watchtower.monitor-only=\"true\"\n</code></pre> <p>Or, it can be specified as part of the <code>docker run</code> command line:</p> <pre><code>docker run -d --label=com.centurylinklabs.watchtower.monitor-only=true someimage\n</code></pre> <p>When the label is specified on a container, Watchtower treats that container exactly as if <code>WATCHTOWER_MONITOR_ONLY</code> was set, but the effect is limited to the individual container.</p>"},{"location":"configuration/private-registries/","title":"Private Registries","text":"<p>Watchtower supports private Docker image registries.</p> <p>In many cases, accessing a private registry requires a valid username and password (i.e., credentials). In order to operate in such an environment, Watchtower needs to know the credentials to access the registry. The credentials can be provided to Watchtower in a configuration file called <code>config.json</code>.</p> <p>There are two ways to generate this configuration file:</p> <ol> <li>The configuration file can be created manually.</li> <li>Call <code>docker login &lt;REGISTRY_NAME&gt;</code> and share the resulting configuration file.</li> </ol>"},{"location":"configuration/private-registries/#creating_the_configuration_file_manually","title":"Creating the configuration file manually","text":"<p>Create a new configuration file with the following syntax and a base64 encoded username and password <code>auth</code> string:</p> config.json<pre><code>{\n    \"auths\": {\n        \"&lt;REGISTRY_NAME&gt;\": {\n            \"auth\": \"XXXXXXX\"\n        }\n    }\n}\n</code></pre> <p><code>&lt;REGISTRY_NAME&gt;</code> needs to be replaced by the name of your private registry (e.g., <code>my-private-registry.example.org</code>).</p>"},{"location":"configuration/private-registries/#using_private_docker_hub_images","title":"Using Private Docker Hub Images","text":"<p>To access private repositories on Docker Hub, <code>&lt;REGISTRY_NAME&gt;</code> should be <code>https://index.docker.io/v1/</code>. The registry domain does not have to be specified in <code>docker run</code> or <code>docker-compose</code>.</p> <p>Like Docker, Watchtower will use the Docker Hub registry and its credentials when no registry domain is specified. Watchtower will recognize credentials with <code>&lt;REGISTRY_NAME&gt;</code> <code>index.docker.io</code>, but the Docker CLI will not.</p>"},{"location":"configuration/private-registries/#using_a_private_registry_on_a_local_host","title":"Using a Private Registry on a Local Host","text":"<p>To use a private registry hosted locally, make sure to correctly specify the registry host in both <code>config.json</code> and the <code>docker run</code> command or <code>docker-compose</code> file. Valid hosts are <code>localhost[:PORT]</code>, <code>HOST:PORT</code>, or any multi-part <code>domain.name</code> or IP-address with or without a port.</p> <p>Examples:</p> <ul> <li><code>localhost</code> -&gt; <code>localhost/myimage</code></li> <li><code>127.0.0.1</code> -&gt; <code>127.0.0.1/myimage:mytag</code></li> <li><code>host.domain</code> -&gt; <code>host.domain/myorganization/myimage</code></li> <li><code>other-lan-host:80</code> -&gt; <code>other-lan-host:80/imagename:latest</code></li> </ul> <p>The required <code>auth</code> string can be generated as follows:</p> <pre><code>echo -n 'username:password' | base64\n</code></pre> <p>Username and Password for GCloud</p> <p>For gcloud, we'll use <code>_json_key</code> as our username and the content of <code>gcloudauth.json</code> as the password. <pre><code>bash echo -n \"_json_key:$(cat gcloudauth.json)\" | base64 -w0\n</code></pre></p> <p>When the Watchtower Docker container is started, the created configuration file (<code>&lt;PATH&gt;/config.json</code> in this example) needs to be passed to the container:</p> <pre><code>docker run [...] -v &lt;PATH&gt;/config.json:/config.json nickfedor/watchtower\n</code></pre>"},{"location":"configuration/private-registries/#sharing_the_docker_configuration_file","title":"Sharing the Docker Configuration File","text":"<p>To pull an image from a private registry, <code>docker login</code> needs to be called first, to get access to the registry. The provided credentials are stored in a configuration file called <code>&lt;PATH_TO_HOME_DIR&gt;/.docker/config.json</code>. This configuration file can be directly used by Watchtower. In this case, the creation of an additional configuration file is not necessary.</p> <p>When the Docker container is started, pass the configuration file to Watchtower:</p> <pre><code>docker run [...] -v &lt;PATH_TO_HOME_DIR&gt;/.docker/config.json:/config.json nickfedor/watchtower\n</code></pre> <p>When creating the Watchtower container via Docker Compose, use the following lines:</p> <pre><code>services:\n  watchtower:\n    image: nickfedor/watchtower:latest\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - &lt;PATH_TO_HOME_DIR&gt;/.docker/config.json:/config.json\n  ...\n</code></pre>"},{"location":"configuration/private-registries/#docker_config_path","title":"Docker Config path","text":"<p>By default, Watchtower will look for the <code>config.json</code> file in <code>/</code>, but this can be changed by setting the <code>DOCKER_CONFIG</code> environment variable to the directory path where your config is located. This is useful for setups where the config.json file is changed while the Watchtower instance is running, as the changes will not be picked up for a mounted file if the inode changes.</p> <p>For example:</p> <pre><code>services:\n  watchtower:\n    image: nickfedor/watchtower\n    environment:\n        DOCKER_CONFIG: /config\n    volumes:\n      - /etc/watchtower/config/:/config/\n      - /var/run/docker.sock:/var/run/docker.sock\n</code></pre>"},{"location":"configuration/private-registries/#credential_helpers","title":"Credential helpers","text":"<p>Some private Docker registries (the most prominent probably being AWS ECR) use non-standard ways of authentication. To be able to use this together with Watchtower, we need to use a credential helper.</p> <p>To keep the image size small we've decided to not include any helpers in the Watchtower image, instead we'll put the helper in a separate container and mount it using volumes.</p>"},{"location":"configuration/private-registries/#example","title":"Example","text":"<p>Here is an example implementation for use with the amazon-ecr-credential-helper:</p> <p>Use the Dockerfile below to build the <code>amazon-ecr-credential-helper</code> image in a volume that may be mounted onto your Watchtower container.</p> <ol> <li> <p>Create the Dockerfile:</p> Example Dockerfile for Amazon ECR Credential Helper<pre><code>FROM golang:1.25\n\nENV GO111MODULE off\nENV CGO_ENABLED 0\nENV REPO github.com/awslabs/amazon-ecr-credential-helper/ecr-login/cli/docker-credential-ecr-login\n\nRUN go get -u $REPO\n\nRUN rm /go/bin/docker-credential-ecr-login\n\nRUN go build \\\n -o /go/bin/docker-credential-ecr-login \\\n /go/src/$REPO\n\nWORKDIR /go/bin/\n</code></pre> </li> <li> <p>Use the following commands to build the <code>aws-ecr-dock-cred-helper</code> and store it's output in a volume:</p> <ul> <li> <p>Create a volume to store the command (once built):</p> <pre><code>docker volume create helper\n</code></pre> </li> <li> <p>Build the container:</p> <pre><code>docker build -t aws-ecr-dock-cred-helper .\n</code></pre> </li> <li> <p>Build the command and store it in the new volume in the <code>/go/bin</code> directory:</p> <pre><code>docker run  -d --rm --name aws-cred-helper \\\n  --volume helper:/go/bin aws-ecr-dock-cred-helper\n</code></pre> </li> </ul> </li> <li> <p>Create a configuration file for Docker, and store it in <code>$HOME/.docker/config.json</code>.    Replace the  placeholders with your <code>AWS Account ID</code> and  with your <code>AWS ECR Region</code>: <pre><code>{\n   \"credsStore\" : \"ecr-login\",\n   \"HttpHeaders\" : {\n     \"User-Agent\" : \"Docker-Client/19.03.1 (XXXXXX)\"\n   },\n   \"auths\" : {\n     \"&lt;AWS_ACCOUNT_ID&gt;.dkr.ecr.&lt;AWS_ECR_REGION&gt;.amazonaws.com\" : {}\n   },\n   \"credHelpers\": {\n     \"&lt;AWS_ACCOUNT_ID&gt;.dkr.ecr.&lt;AWS_ECR_REGION&gt;.amazonaws.com\" : \"ecr-login\"\n   }\n}\n</code></pre> <pre><code>services:\n # Check for new images and restart things if a new image exists\n # for any of our containers.\n watchtower:\n   image: nickfedor/watchtower:latest\n   volumes:\n     - /var/run/docker.sock:/var/run/docker.sock\n     - .docker/config.json:/config.json\n     - helper:/go/bin\n   environment:\n     - HOME=/\n     - PATH=$PATH:/go/bin\n     - AWS_REGION=us-west-1\nvolumes:\n helper:\n   external: true\n</code></pre> <p>A few additional notes:</p> <ol> <li> <p>The volume (helper, in this case) MUST be set to <code>external: true</code>, otherwise Docker Compose will preface it with the directory name.</p> </li> <li> <p>Note that \"credsStore\" : \"ecr-login\" is needed - and in theory if you have that you can remove the credHelpers section</p> </li> <li> <p>This may be able to run in an EC2 instance that has credentials assigned to it, so no keys are needed; however, you may need to include the <code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code> environment variables as well.</p> </li> </ol> <p>Then, mount the <code>~/.aws</code> directory to <code>/</code> in the container.</p>"},{"location":"configuration/secure-connections/","title":"Securely Connecting Watchtower to Docker","text":""},{"location":"configuration/secure-connections/#overview","title":"Overview","text":"<p>Watchtower supports secure TLS connections to Docker hosts through its usage of Docker's Go SDK to create a Docker client.</p> <p>It is highly recommended to review Docker's documentation:</p> <ul> <li>https://docs.docker.com/engine/daemon/remote-access/</li> <li>https://docs.docker.com/engine/security/protect-access</li> <li>https://docs.docker.com/reference/cli/dockerd/#daemon-socket-option</li> </ul> <p>Note</p> <p>Docker has retired the Docker Machine project that was previously noted in Watchtower's documentation.</p>"},{"location":"configuration/secure-connections/#configuration","title":"Configuration","text":""},{"location":"configuration/secure-connections/#tls_verification","title":"TLS Verification","text":"<pre><code>            Argument: --tlsverify\nEnvironment Variable: DOCKER_TLS_VERIFY\n                Type: Boolean\n             Default: false\n</code></pre> <p><code>http://</code> and <code>unix://</code> schemes are incompatible with TLS verification.</p> <p>When TLS verification is enabled</p> <ul> <li>The use of <code>tcp://</code> or <code>https://</code> schemes for the Docker host URL is required.</li> <li><code>tcp://</code> is converted to <code>https://</code> when TLS verification is enabled.</li> </ul>"},{"location":"configuration/secure-connections/#tls_certificate_path","title":"TLS Certificate Path","text":"<pre><code>            Argument: --cert-path\nEnvironment Variable: DOCKER_CERT_PATH\n                Type: String\n             Default: /etc/ssl/docker\n</code></pre> <p>Notes</p> <ul> <li>This specifies the directory where Watchtower's Docker client should find the certificate files within the Watchtower container.</li> <li>Docker expects the following filenames:<ul> <li><code>ca.pem</code></li> <li><code>cert.pem</code></li> <li><code>key.pem</code></li> </ul> </li> </ul>"},{"location":"configuration/secure-connections/#docker_host_url","title":"Docker Host URL","text":"<pre><code>            Argument: --host\nEnvironment Variable: DOCKER_HOST\n                Type: String\n             Default: unix:///var/run/docker.sock\n</code></pre> <p>Specifying multiple connections, such as both the local socket (i.e. <code>/var/run/docker.sock</code>) and a remote host is not supported.</p> <p>Notes</p> <ul> <li>This is required for connections to any Docker host.</li> <li>The use of <code>tcp://</code> or <code>https://</code> schemes is required when using a TLS connection.</li> <li><code>tcp://</code> is internally converted to <code>https://</code> when TLS verification is enabled.</li> </ul>"},{"location":"configuration/secure-connections/#docker_api_version","title":"Docker API Version","text":"<pre><code>            Argument: --api-version\nEnvironment Variable: DOCKER_API_VERSION\n                Type: String\n             Default: &lt;Auto-negotiated&gt;\n</code></pre> <p>Notes</p> <ul> <li>This provides the ability to manually specify the Docker API version.</li> <li>The default version autonegotiation should be sufficient for normal use cases.</li> </ul>"},{"location":"configuration/secure-connections/#examples","title":"Examples","text":"<p>Note</p> <p>Replace <code>remote-host</code> with your actual Docker host address and <code>/path/to/certs</code> with the path to your certificate directory.</p> Docker CLIDocker Compose <pre><code>docker run -d \\\n  --name watchtower \\\n  -v /path/to/certs:/etc/ssl/docker:ro \\\n  nickfedor/watchtower --host tcp://remote-host:2376 --cert-path /etc/ssl/docker --tlsverify\n</code></pre> Parameter Description <code>--name watchtower</code> Assigns the name \"watchtower\" to the container for easy identification and management. <code>-v /path/to/certs:/etc/ssl/docker:ro</code> Mounts the local certificate directory to the container's SSL directory as read-only. <code>nickfedor/watchtower</code> Specifies the Docker image to run, which is the Watchtower container image. <code>--host tcp://remote-host:2376</code> Sets the Docker host to connect to via TCP on port 2376. <code>--cert-path /etc/ssl/docker</code> Defines the path inside the container where TLS certificates are located. <code>--tlsverify</code> Enables TLS verification for secure connections to the Docker host. <p>Tip</p> <p>If using <code>-e</code> flags to pass environment variables, then remember to place them before the <code>nickfedor/watchtower</code> image reference.</p> <pre><code>services:\n  watchtower:\n    image: nickfedor/watchtower\n    environment:\n      - DOCKER_HOST=tcp://remote-host:2376\n      - DOCKER_CERT_PATH=/etc/ssl/docker\n      - DOCKER_TLS_VERIFY=1\n    volumes:\n      - /path/to/certs:/etc/ssl/docker:ro\n    restart: unless-stopped\n</code></pre> Parameter Description <code>image: nickfedor/watchtower</code> Specifies the Docker image for the Watchtower service. <code>- DOCKER_HOST=tcp://remote-host:2376</code> Sets the Docker host connection URL. <code>- DOCKER_CERT_PATH=/etc/ssl/docker</code> Specifies the path to the directory containing TLS certificates. <code>- DOCKER_TLS_VERIFY=1</code> Enables TLS verification for secure connections. <code>/path/to/certs:/etc/ssl/docker:ro</code> Mounts the local certificate directory to the container's SSL directory as read-only. <code>restart: unless-stopped</code> Configures the container to restart automatically unless it was manually stopped."},{"location":"configuration/secure-connections/#basic_tutorial","title":"Basic Tutorial","text":"<p>This is not a comprehensive guide and is merely a simple tutorial to illustrate a basic test deployment.</p> <p>The following tutorial is intended to provide a basic walkthrough for manually setting up Watchtower to perform container updates on a Docker host that has enabled access to the Docker daemon using TLS.</p> <p>This largely follow's Docker's guide for setting up TLS on the Docker host.</p> <p>Warning</p> <p>Configuring Docker to accept network connections has critical security implications that can leave you vulnerable to unauthorized access. You are highly encouraged to perform your own due diligence to mitigate these risks.</p>"},{"location":"configuration/secure-connections/#tutorial_overview","title":"Tutorial Overview","text":"<p>In order for Watchtower to connect via TLS to a Docker daemon, the Docker daemon must be setup to accept remote connections using TLS.</p> <p>Setting up TLS for Docker involves several key steps:</p> <ol> <li> <p>Certificate Generation:</p> <ul> <li>Create a Certificate Authority (CA), server certificate, and client certificates using OpenSSL or similar tools.</li> </ul> <p>Server certificates must include the Docker host's IP or DNS name in the Subject Alternative Name (SAN) field.</p> </li> <li> <p>Daemon Configuration:</p> <p>Start the Docker daemon with TLS options:</p> <ul> <li><code>--tlsverify</code>: Enable TLS verification</li> <li><code>--tlscacert</code>: Path to CA certificate</li> <li><code>--tlscert</code>: Path to server certificate</li> <li><code>--tlskey</code>: Path to server private key</li> </ul> </li> <li> <p>Client Setup:</p> <ul> <li>Prepare client certificates (<code>cert.pem</code> and <code>key.pem</code>) for authentication.</li> </ul> </li> <li> <p>Environment Variables:</p> <ul> <li>Set <code>DOCKER_HOST</code> to the secure endpoint (e.g., <code>tcp://host:2376</code>)</li> <li>Set <code>DOCKER_CERT_PATH</code> to the directory containing client certificates</li> <li>Set <code>DOCKER_TLS_VERIFY=1</code> to enable verification</li> </ul> </li> </ol> <p>For detailed instructions, refer to the Docker documentation on protecting the Docker daemon socket.</p>"},{"location":"configuration/secure-connections/#certificate_generation","title":"Certificate Generation","text":"<p>Generate self-signed certificates for testing (replace with proper certificates for production):</p>"},{"location":"configuration/secure-connections/#create_a_ca_key_and_certificate","title":"Create a CA Key and Certificate","text":"<ol> <li> <p>Generate a 4096-bit RSA private key for the Certificate Authority and save it to <code>ca-key.pem</code>:</p> <pre><code>openssl genrsa -aes256 -out ca-key.pem 4096\n</code></pre> <p>Make sure to take note of the passphrase</p> </li> <li> <p>Create a self-signed X.509 certificate for the Certificate Authority (valid for 365 days) using the private key and save it to <code>ca.pem</code>:</p> <pre><code>openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem -subj \"/C=US/ST=State/L=City/O=Org/CN=ca\"\n</code></pre> </li> </ol>"},{"location":"configuration/secure-connections/#create_a_server_key_and_certificate","title":"Create a Server Key and Certificate","text":"<ol> <li> <p>Generate a 4096-bit RSA private key for the server certificate and save it to <code>server-key.pem</code>:</p> <pre><code>openssl genrsa -out server-key.pem 4096\n</code></pre> </li> <li> <p>Generate a certificate signing request (CSR) for the server with common name \"localhost\" and save it to <code>server.csr</code>:</p> <pre><code>openssl req -subj \"/CN=$HOST\" -sha256 -new -key server-key.pem -out server.csr\n</code></pre> </li> <li> <p>Sign the server CSR with the CA certificate, creating a server certificate valid for 365 days with the specified extensions, and save it to <code>server-cert.pem</code>:</p> <pre><code>echo \"subjectAltName = DNS:$HOST,IP:10.10.10.20,IP:127.0.0.1\" &gt; extfile-server.cnf\n</code></pre> <p><code>IP:10.10.10.20</code> is an example IP. Replace with your host's actual IP.</p> <p><code>$HOST</code> typically resolves to the hostname. Change this as necessary (i.e. <code>localhost</code> for testing) </p> <pre><code>echo \"extendedKeyUsage = serverAuth\" &gt;&gt; extfile-server.cnf\n</code></pre> <p>This sets the Docker daemon key's extended usage attributes to be used only for server authentication.</p> <pre><code>openssl x509 -req -days 365 -sha256 -in server.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out server-cert.pem -extfile extfile-server.cnf\n</code></pre> </li> </ol>"},{"location":"configuration/secure-connections/#create_a_client_key_and_certificate","title":"Create a Client Key and Certificate","text":"<ol> <li> <p>Generate a 4096-bit RSA private key for the client certificate and save it to <code>key.pem</code>:</p> <pre><code>openssl genrsa -out key.pem 4096\n</code></pre> </li> <li> <p>Generate a certificate signing request (CSR) for the client with common name \"client\" and save it to <code>client.csr</code>:</p> <pre><code>openssl req -subj '/CN=client' -new -key key.pem -out client.csr\n</code></pre> </li> <li> <p>Sign the client CSR with the CA certificate, creating a client certificate valid for 365 days with the client authentication extension, and save it to <code>cert.pem</code>:</p> <pre><code>echo \"extendedKeyUsage = clientAuth\" &gt; extfile-client.cnf\n</code></pre> <p>This makes the key suitable for client authentication.</p> <pre><code>openssl x509 -req -days 365 -sha256 -in client.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out cert.pem -extfile extfile-client.cnf\n</code></pre> </li> </ol>"},{"location":"configuration/secure-connections/#key_and_certificate_management","title":"Key and Certificate Management","text":"<ol> <li> <p>Remove both the certificate signing requests (<code>client.csr</code> and <code>server.csr</code>) and extensions config files (<code>extfile-server.cnf</code> and <code>extfile-client.cnf</code>) after generating the server (<code>server-cert.pem</code>) and client <code>cert.pem</code> certificates:</p> <pre><code>rm -v client.csr server.csr extfile-server.cnf extfile-client.cnf\n</code></pre> </li> <li> <p>Update the file permissions of the <code>ca-key.pem</code>, <code>server-key.pem</code>, and <code>key.pem</code> secret keys:</p> <pre><code>sudo chmod -v 0400 ca-key.pem server-key.pem key.pem\n</code></pre> </li> <li> <p>Remove <code>ca.pem</code>, <code>server-cert.pem</code>, and <code>cert.pem</code> file write access:</p> <pre><code>sudo chmod -v 0444 ca.pem server-cert.pem cert.pem\n</code></pre> </li> <li> <p>Create the <code>/etc/docker/certs</code> directory if it doesn't exist:</p> <pre><code>sudo mkdir -p /etc/docker/certs\n</code></pre> </li> <li> <p>Copy the server-specific files:</p> <pre><code>sudo cp ca.pem ca-key.pem server-cert.pem server-key.pem /etc/docker/certs/\n</code></pre> </li> <li> <p>(Optional): Copy the client-specific files:</p> <pre><code>sudo cp cert.pem key.pem /etc/docker/certs/\n</code></pre> </li> <li> <p>Ensure root ownership:</p> <pre><code>sudo chown root:root /etc/docker/certs/*\n</code></pre> </li> <li> <p>Set directory-level access:</p> <pre><code>sudo chmod 0755 /etc/docker/certs/\n</code></pre> </li> <li> <p>Verify the files:</p> <pre><code>ls -la /etc/docker/certs/\n</code></pre> <p>Output should show files with <code>-r--------</code> for keys and <code>-r--r--r--</code> for certs.</p> </li> <li> <p>(Optional) Remove the original files (in the original directory, not <code>/etc/docker/certs</code>):</p> <pre><code>rm -v {ca,ca-key,server-cert,server-key,cert,key}.pem\n</code></pre> </li> </ol> <p>Notes</p> <ul> <li>The server files (<code>ca.pem</code>, <code>server-key.pem</code>, <code>server-cert.pem</code>) stay on the daemon host.</li> <li>The client's files (<code>ca.pem</code>, <code>key.pem</code>, and <code>cert.pem</code>) can be moved the client's Docker directory (e.g. <code>~/.docker/</code>).</li> </ul>"},{"location":"configuration/secure-connections/#setup_the_docker_daemon_with_tls","title":"Setup the Docker Daemon with TLS","text":"<p>This assumes Docker is already installed on the host system.</p> <ol> <li> <p>Edit or create <code>/etc/docker/daemon.json</code> to enable TLS and TCP listening:</p> <pre><code>{\n  \"tls\": true,\n  \"tlscacert\": \"/etc/docker/certs/ca.pem\",\n  \"tlscert\": \"/etc/docker/certs/server-cert.pem\",\n  \"tlskey\": \"/etc/docker/certs/server-key.pem\",\n  \"hosts\": [\"unix:///var/run/docker.sock\", \"tcp://0.0.0.0:2376\"]\n}\n</code></pre> <p>Notes</p> <ul> <li><code>\"tls\": true</code> enables TLS verification.</li> <li><code>\"hosts\": [\"unix:///var/run/docker.sock\", \"tcp://0.0.0.0:2376\"]</code> adds TCP listening on port 2376 and retains the Unix socket for local access.</li> <li>Alternatively, use dockerd flags in <code>/etc/systemd/system/docker.service.d/override.conf</code> for overrides without editing <code>daemon.json</code>.</li> </ul> </li> <li> <p>Restart the daemon:</p> <pre><code>sudo systemctl restart docker\n</code></pre> </li> <li> <p>Verify the daemon is listening:</p> <pre><code>sudo netstat -tlnp | grep 2376\n</code></pre> </li> </ol>"},{"location":"configuration/secure-connections/#watchtower_configuration","title":"Watchtower Configuration","text":"Docker CLIDocker Compose <pre><code>docker run -d \\\n  --name watchtower \\\n  -v /path/to/certs:/etc/ssl/docker:ro \\\n  nickfedor/watchtower --host tcp://remote-host:2376 --cert-path /etc/ssl/docker --tlsverify\n</code></pre> <pre><code>services:\n  watchtower:\n    image: nickfedor/watchtower\n    environment:\n      - DOCKER_HOST=tcp://remote-host:2376\n      - DOCKER_CERT_PATH=/etc/ssl/docker\n      - DOCKER_TLS_VERIFY=1\n    volumes:\n      - /path/to/certs:/etc/ssl/docker:ro\n    restart: unless-stopped\n</code></pre> <p><code>remote-host</code> is used, but can be replaced with <code>localhost</code> for local testing.</p>"},{"location":"configuration/secure-connections/#troubleshooting","title":"Troubleshooting","text":""},{"location":"configuration/secure-connections/#insecure_scheme_with_tls_verification","title":"Insecure Scheme with TLS Verification","text":"<p>When TLS verification is enabled and the Docker host URL uses <code>http://</code>,  Watchtower logs the following warning:</p> <p>TLS verification is enabled but DOCKER_HOST uses insecure scheme 'http://'. Consider using 'https://' or disable TLS verification.</p> <p>Possible Solutions:</p> <ul> <li>If using a secure connection, then use <code>https://</code>.</li> <li>If using <code>http://</code>, then disable TLS verification.</li> </ul>"},{"location":"configuration/secure-connections/#local_socket_with_tls_verification","title":"Local Socket with TLS Verification","text":"<p>When TLS verification is enabled and the Docker host URL is not configured or uses <code>unix://</code>,  Watchtower logs the following warning:</p> <p>TLS verification is enabled but DOCKER_HOST uses local socket 'unix://'. TLS is not applicable for local sockets; consider disabling TLS verification.</p> <p>Possible Solutions:</p> <ul> <li>If the Docker host URL is not configured, then the default <code>unix:///var/run/docker.sock</code> is used.</li> <li>If using a local socket (i.e. <code>unix://</code>), then disable TLS verification.</li> </ul>"},{"location":"configuration/secure-connections/#missing_tls_certificates","title":"Missing TLS Certificates","text":"<p>In order for Watchtower's Docker client to connect to the Docker daemon via TLS, the certificates must be provided to the Watchtower container.</p> <p>If the certificates are available via the host filesystem of the Watchtower container's Docker host, then this can be accomplished using bind mounts. Other options, such as building a custom Watchtower image with the certificates, are outside the scope of this documentation.</p> <p>Refer to the documentation for the TLS Certificate Path and the examples.</p>"},{"location":"configuration/secure-connections/#other_common_mistakes","title":"Other Common Mistakes","text":"<ul> <li>Using <code>tcp://</code> without <code>--tlsverify</code>: This disables TLS, potentially allowing insecure connections.</li> <li>Mismatched certificate paths: Ensure <code>DOCKER_CERT_PATH</code> points to the correct directory containing <code>cert.pem</code> and <code>key.pem</code>.</li> <li>Expired or invalid certificates: Check certificate validity and SAN fields matching the host.</li> <li>Firewall blocking TLS port: Ensure port 2376 is open for remote connections.</li> </ul>"},{"location":"configuration/secure-connections/#certificate_management","title":"Certificate Management","text":"<p>This documentation is not intended to be a guide on TLS/mTLS certificate deployment or management. Manual certificate management might be acceptable for smaller deployments; however, there are solutions for automating certificate management. If you are exposing your Docker daemon to external network connections, then both proper TLS setup and management is a highly recommended.</p> <p>Here are just a few available solutions:</p> <ul> <li>Step-CA: Smallstep's private, self-hostable certificate authority. [Tutorial]</li> <li>Vault: HashiCorp's secret management tool with PKI secrets engine for certificate generation</li> <li>CFSSL: Cloudflare's PKI toolkit for certificate management</li> </ul>"},{"location":"configuration/secure-connections/#docker_socket_proxies","title":"Docker Socket Proxies","text":"<p>You are highly encouraged to perform your own due diligence before using any software that interacts directly with the Docker socket.</p> <p>Docker socket proxies provide a security layer between applications and the Docker daemon by filtering API calls and preventing unrestricted access to the Docker socket.</p> <p>While this documentation focuses on TLS-based connections, socket proxies represent another approach for securing Docker daemon access in environments where full socket exposure is undesirable.</p> <p>The following projects are examples of Docker socket proxies:</p> <ul> <li>Tecnativa/docker-socket-proxy</li> <li>11notes/docker-socket-proxy</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#sources","title":"Sources","text":""},{"location":"getting-started/installation/#container_image","title":"Container Image","text":"<ul> <li>Docker Hub</li> <li>GitHub Container Registry</li> </ul>"},{"location":"getting-started/installation/#binary","title":"Binary","text":"<ul> <li>GitHub Releases</li> </ul>"},{"location":"getting-started/installation/#cli_commands","title":"CLI Commands","text":""},{"location":"getting-started/installation/#pulling_the_container_image","title":"Pulling the Container Image","text":"Docker HubGitHub <pre><code>docker pull nickfedor/watchtower:latest\n</code></pre> <pre><code>docker pull ghcr.io/nicholas-fedor/watchtower:latest\n</code></pre>"},{"location":"getting-started/installation/#downloading_the_binary","title":"Downloading the Binary","text":"<p>The following will download and extract the binary to the current directory:</p> Windows (amd64)Linux (amd64)macOS (amd64) PowerShell<pre><code>iwr (iwr https://api.github.com/repos/nicholas-fedor/watchtower/releases/latest | ConvertFrom-Json).assets.where({$_.name -like \"*windows_amd64*.zip\"}).browser_download_url -OutFile watchtower.zip; Add-Type -AssemblyName System.IO.Compression.FileSystem; $zip = [System.IO.Compression.ZipFile]::OpenRead(\"$PWD\\watchtower.zip\"); $zip.Entries | Where-Object {$_.Name -eq 'watchtower.exe'} | ForEach-Object {[System.IO.Compression.ZipFileExtensions]::ExtractToFile($_, \"$PWD\\watchtower.exe\", $true)}; $zip.Dispose(); Remove-Item watchtower.zip; if (Test-Path \".\\watchtower.exe\") { Write-Host \"Successfully installed watchtower.exe to current directory\" } else { Write-Host \"Failed to install watchtower.exe\" }\n</code></pre> Bash<pre><code>curl -L $(curl -s https://api.github.com/repos/nicholas-fedor/watchtower/releases/latest | grep -o 'https://[^\"]*linux_amd64[^\"]*\\.tar\\.gz') | tar -xz -C . watchtower &amp;&amp; if [ -f ./watchtower ]; then echo \"Successfully installed watchtower to current directory\"; else echo \"Failed to install watchtower\"; fi\n</code></pre> Bash<pre><code>curl -L $(curl -s https://api.github.com/repos/nicholas-fedor/watchtower/releases/latest | grep -o 'https://[^\"]*darwin_amd64[^\"]*\\.tar\\.gz') | tar -xz -C . watchtower &amp;&amp; if [ -f ./watchtower ]; then echo \"Successfully installed watchtower to current directory\"; else echo \"Failed to install watchtower\"; fi\n</code></pre> <p>Note</p> <p>Review the release page for additional architectures (e.g., arm, arm64, i386, riscv64).</p>"},{"location":"getting-started/installation/#supported_architectures","title":"Supported Architectures","text":"<p>Watchtower supports the following architectures:</p> <ul> <li>amd64</li> <li>i386</li> <li>armhf</li> <li>arm64v8</li> <li>riscv64</li> </ul>"},{"location":"getting-started/overview/","title":"Overview","text":"<p>Watchtower is an application that will monitor your running Docker containers and watch for changes to the images that those containers were originally started from. If Watchtower detects that an image has changed, it will automatically restart the container using the new image.</p> <p>With Watchtower you can update the container by pushing a new image to the registry that's repective to the container's image. Watchtower will pull the new image, gracefully shut down the existing container, and restart it with the same options that were used when it was deployed initially.</p>"},{"location":"getting-started/overview/#how_image_updates_work","title":"How Image Updates Work","text":"<p>Watchtower monitors containers using their exact image reference, including any tags specified.</p> <p>This means:</p> <ul> <li>A container running <code>nginx:1.29</code> will only be updated when new images become available under the <code>nginx:1.29</code> tag</li> <li>It will not update when <code>nginx:latest</code>, <code>nginx:1.30</code>, or other tags receive updates</li> <li>A container running <code>myapp</code> (without a tag) will update when <code>myapp:latest</code> changes</li> </ul> <p>This tag-specific behavior provides fine-grained control over update scopes, allowing you to pin containers to specific versions while still receiving updates within that version series.</p>"},{"location":"getting-started/overview/#examples_of_different_tagging_schemes","title":"Examples of Different Tagging Schemes","text":"<p>While semantic versioning is ideal for predictable updates, many popular Docker images use different approaches.</p> <p>The following examples show how Watchtower handles various tag types:</p> Latest TagsSemantic Version TagsOther Tagging Schemes <p>Containers using the implicit or explicit <code>latest</code> tag will update when the image maintainer pushes new content to the <code>latest</code> tag.</p> Running an nginx:latest container<pre><code>CONTAINER ID   IMAGE          STATUS          PORTS                    NAMES\nabc123def456   nginx:latest   Up 10 minutes   0.0.0.0:80-&gt;80/tcp       webserver\n</code></pre> <p>Expected behavior:</p> <p>Watchtower checks for updates to <code>nginx:latest</code>. If nginx releases a new version and tags it as <code>latest</code>, the container will be updated.</p> <p>This is commonly used, but can lead to unexpected changes because <code>latest</code> may include breaking changes from major version updates.</p> <p>Semantic versioning (e.g., <code>1.29</code>) provides more predictable updates within a major version.</p> Running an nginx:1.29 container<pre><code>CONTAINER ID   IMAGE          STATUS          PORTS                    NAMES\ndef456ghi789   nginx:1.29     Up 10 minutes   0.0.0.0:80-&gt;80/tcp       webserver\n</code></pre> <p>Expected behavior:</p> <p>Watchtower monitors the image <code>nginx:1.29</code> specifically. When nginx releases a new patch for version 1.29 (e.g. <code>1.29.1</code>, <code>1.29.2</code>, etc.), the maintainers will typically build and release a new patched version of the image with the <code>1.29</code> tag being applied to the updated image. Watchtower will then update the container to reflect the updated, <code>1.29</code>-tagged image.</p> <p>Some images use date-based or incremental versioning schemes instead of semantic versioning.</p> Running a pihole:2023.11 container<pre><code>CONTAINER ID   IMAGE               STATUS          PORTS                    NAMES\nghi789jkl012   pihole/pihole:2023.11   Up 10 minutes   0.0.0.0:8080-&gt;80/tcp   pihole\n</code></pre> <p>Expected behavior:</p> <p>Watchtower checks for updates to <code>pihole/pihole:2023.11</code>. Pi-hole releases updates like <code>2023.11.1</code>, <code>2023.11.2</code> within the same month/year tag. The container updates to the latest patch within that period but not to <code>2023.12</code> or newer major releases.</p>"},{"location":"getting-started/updating-watchtower/","title":"Updating Watchtower","text":"<p>If Watchtower is monitoring the same Docker daemon under which the Watchtower container itself is running (i.e. if you volume-mounted <code>/var/run/docker.sock</code> into the Watchtower container) then it has the ability to update itself.</p> <p>If a new version of the <code>nickfedor/watchtower</code> image is pushed to the Docker Hub, your Watchtower will pull down the new image and restart itself automatically.</p>"},{"location":"getting-started/usage/","title":"Usage","text":""},{"location":"getting-started/usage/#running_watchtower_as_a_docker_container","title":"Running Watchtower as a Docker Container","text":"<p>Watchtower is released as a container image, which makes getting started as simple as pulling the <code>nickfedor/watchtower</code> image.</p> <p>Note</p> <p>If you are using an ARM-based system, then remember to pull the appropriate <code>nickfedor/watchtower:armhf-&lt;tag&gt;</code> image from Docker Hub.</p>"},{"location":"getting-started/usage/#docker_socket_requirement","title":"Docker Socket Requirement","text":"<p>Since Watchtower needs to interact with the Docker API in order to monitor and update containers, you need to mount <code>/var/run/docker.sock</code> to the Watchtower container with the <code>-v</code> flag.</p>"},{"location":"getting-started/usage/#docker_engine_dependency","title":"Docker Engine Dependency","text":"<p>It is recommended to use the latest version of Docker. You can check your host's Docker version using the following CLI command:</p> <pre><code>docker version\n</code></pre> <p>Docker CLI Command Reference</p> <p>Watchtower autonegotiates the API version by default. If the <code>DOCKER_API_VERSION</code> variable is explicitly set, then Watchtower validates the version and falls back to autonegotiation on failure.</p> <p>This version of Watchtower has been tested to support Docker v1.43 and higher. There is an increased probability of failures when using outdated versions of Docker.</p>"},{"location":"getting-started/usage/#running_the_container","title":"Running the Container","text":"<p>Run the <code>watchtower</code> container with the following command:</p> <pre><code>docker run -d \\\n  --name watchtower \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  --restart unless-stopped \\\n  nickfedor/watchtower\n</code></pre>"},{"location":"getting-started/usage/#private_registries","title":"Private Registries","text":"<p>If pulling images from private Docker registries, then supply registry authentication credentials with the environment variables <code>REPO_USER</code> and <code>REPO_PASS</code> or by mounting the host's docker config file into the container (at the root of the container filesystem <code>/</code>).</p>"},{"location":"getting-started/usage/#passing_environment_variables","title":"Passing Environment Variables","text":"<pre><code>docker run -d \\\n  --name watchtower \\\n  -e REPO_USER=username \\\n  -e REPO_PASS=password \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  --restart unless-stopped \\\n  nickfedor/watchtower container_to_watch --debug\n</code></pre> <p>Also check out this Stack Overflow answer for more options on how to pass environment variables.</p>"},{"location":"getting-started/usage/#docker_hub_credentials","title":"Docker Hub Credentials","text":"<p>Alternatively, if you 2FA authentication setup on Docker Hub, then passing username and password will be insufficient. Instead you can run <code>docker login</code> to store your credentials in <code>$HOME/.docker/config.json</code> and then mount this config file to make it available to the Watchtower container:</p> <pre><code>docker run -d \\\n  --name watchtower \\\n  -v $HOME/.docker/config.json:/config.json \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  --restart unless-stopped \\\n  nickfedor/watchtower container_to_watch --debug\n</code></pre> <p>Changes to config.json while running</p> <p>If you mount <code>config.json</code> in the manner above, changes from the host system will (generally) not be propagated to the running container.</p> <p>Mounting files into the Docker daemon uses bind mounts, which are based on inodes.</p> <p>Most applications (including <code>docker login</code> and <code>vim</code>) will not directly edit the file, but instead make a copy and replace the original file, which results in a new inode which in turn breaks the bind mount.</p> <p>As a workaround, you can create a symlink to your <code>config.json</code> file and then mount the symlink in the container. The symlinked file will always have the same inode, which keeps the bind mount intact and will ensure changes to the original file are propagated to the running container (regardless of the inode of the source file!).</p> <p>If you mount the config file as described above, be sure to also prepend the URL for the registry when starting up your watched image (you can omit the https://).</p> <p>Here is a complete docker-compose.yml file that starts up a docker container from a private repo on the GitHub Registry and monitors it with Watchtower. Note the command argument changing the interval to 30s rather than the default 24 hours.</p> <pre><code>version: \"3\"\nservices:\n  cavo:\n    image: ghcr.io/&lt;org&gt;/&lt;image&gt;:&lt;tag&gt;\n    ports:\n      - \"443:3443\"\n      - \"80:3080\"\n  watchtower:\n    image: nickfedor/watchtower\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - /root/.docker/config.json:/config.json\n    command: --interval 30\n</code></pre>"},{"location":"notifications/overview/","title":"Configuration","text":""},{"location":"notifications/overview/#overview","title":"Overview","text":"<p>Watchtower uses Shoutrrr to provide notification functionality. Notifications are sent via hooks in the logrus logging system.</p>"},{"location":"notifications/overview/#enabling_notifications","title":"Enabling Notifications","text":"<p>To send notifications, use the <code>NOTIFICATION URL</code> configuration option to specify the Shoutrrr service URL.</p> <p>The Shoutrrr URL follows the format:</p> <pre><code>&lt;service&gt;://&lt;required-credentials&gt;[:&lt;optional-credentials&gt;]@&lt;required-service&gt;/&lt;required-path&gt;?&lt;key&gt;=&lt;value&gt;&amp;...\n</code></pre> <p>The format is the same for all services, but the parameters, path, and credentials vary between them.</p> <p>The <code>NOTIFICATION URL</code> configuration option can also reference a file, in which case the contents of the file are used.</p>"},{"location":"notifications/overview/#using_multiple_notification_services","title":"Using Multiple Notification Services","text":"<p>The <code>NOTIFICATION URL</code> configuration option can also be used multiple times or use a comma-separated list in the <code>WATCHTOWER_NOTIFICATION_URL</code> environment variable to utilize multiple notification services.</p> <p>Using multiple notifications with environment variables</p> <p>There is currently a bug in Viper (Issue), which prevents comma-separated slices to be used when using the environment variable.</p> <p>A workaround is available where we instead put quotes around the environment variable value and replace the commas with spaces:</p> <pre><code>WATCHTOWER_NOTIFICATIONS=\"slack msteams\"\n</code></pre> <p>If you're a <code>docker-compose</code> user, make sure to specify environment variables' values in your <code>.yml</code> file without double quotes (<code>\"</code>). This prevents unexpected errors when Watchtower starts.</p>"},{"location":"notifications/overview/#startup_notifications","title":"Startup Notifications","text":"<p>Watchtower will log and send a notification every time it is started.</p> <p>This behavior can be disabled with the <code>DISABLE STARTUP MESSAGE</code> configuration option.</p>"},{"location":"notifications/overview/#general_notification_settings","title":"General Notification Settings","text":""},{"location":"notifications/overview/#level","title":"Level","text":"<p>Controls the log level for notifications.</p> <p>Possible values: <code>panic</code>, <code>fatal</code>, <code>error</code>, <code>warn</code>, <code>info</code>, <code>debug</code>, <code>trace</code>.</p> <pre><code>            Argument: --notifications-level\nEnvironment Variable: WATCHTOWER_NOTIFICATIONS_LEVEL\n                Type: String\n             Default: info\n</code></pre> <p>Note</p> <p>In legacy mode (<code>--notification-report=false</code>), only <code>info</code>-level logs trigger notifications, ensuring a focused step-by-step update summary.</p>"},{"location":"notifications/overview/#hostname","title":"Hostname","text":"<p>Custom hostname specified in subject/title. Useful for overriding the operating system hostname.</p> <pre><code>            Argument: --notifications-hostname\nEnvironment Variable: WATCHTOWER_NOTIFICATIONS_HOSTNAME\n                Type: String\n             Default: None\n</code></pre>"},{"location":"notifications/overview/#delay","title":"Delay","text":"<p>Delay before sending notifications expressed in seconds.</p> <pre><code>            Argument: --notifications-delay\nEnvironment Variable: WATCHTOWER_NOTIFICATIONS_DELAY\n                Type: Integer\n             Default: None\n</code></pre>"},{"location":"notifications/overview/#title_tag","title":"Title Tag","text":"<p>Prefix to include in the title. Useful when running multiple Watchtower instances.</p> <pre><code>            Argument: --notification-title-tag\nEnvironment Variable: WATCHTOWER_NOTIFICATION_TITLE_TAG\n                Type: String\n             Default: None\n</code></pre>"},{"location":"notifications/overview/#skip_title","title":"Skip Title","text":"<p>Used to not pass the title param to notifications. This will not pass a dynamic title override to notification services. If no title is configured for the service, it will remove the title altogether.</p> <pre><code>            Argument: --notification-skip-title\nEnvironment Variable: WATCHTOWER_NOTIFICATION_SKIP_TITLE\n                Type: Boolean\n             Default: false\n</code></pre>"},{"location":"notifications/overview/#log_stdout","title":"Log Stdout","text":"<p>Enable output from <code>logger://</code> Shoutrrr service to stdout.</p> <pre><code>            Argument: --notification-log-stdout\nEnvironment Variable: WATCHTOWER_NOTIFICATION_LOG_STDOUT\n                Type: Boolean\n             Default: false\n</code></pre>"},{"location":"notifications/overview/#split_by_container","title":"Split by Container","text":"<p>Send separate notifications for each updated container instead of grouping them.</p> <pre><code>            Argument: --notification-split-by-container\nEnvironment Variable: WATCHTOWER_NOTIFICATION_SPLIT_BY_CONTAINER\n                Type: Boolean\n             Default: false\n</code></pre> <p>Note</p> <p>When disabled (default), notifications are grouped for all updated containers in a single session. When enabled, a separate notification is sent for each container update.</p>"},{"location":"notifications/overview/#usage_example","title":"Usage Example","text":"<p>To enable separate notifications per container:</p> <pre><code>docker run -d \\\n  --name watchtower \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -e WATCHTOWER_NOTIFICATIONS=slack \\\n  -e WATCHTOWER_NOTIFICATION_SLACK_HOOK_URL=\"https://hooks.slack.com/services/xxx/yyyyyyyyyyyyyyy\" \\\n  -e WATCHTOWER_NOTIFICATION_SPLIT_BY_CONTAINER=true \\\n  nickfedor/watchtower\n</code></pre>"},{"location":"notifications/overview/#email_notifications","title":"Email Notifications","text":"<p>Watchtower uses Shoutrrr's smtp service to send email notifications.</p> <p>Either legacy email notification flags or Shoutrrr URLs can be used; however, directly using URLs is recommended for greater control and clarity, especially for configuring TLS settings (e.g., STARTTLS or Implicit TLS).</p> <p>To send notifications via e-mail, add <code>email</code> to the <code>--notifications</code> option or the <code>WATCHTOWER_NOTIFICATIONS</code> environment variable.</p> <p>Email notification flags (e.g., <code>WATCHTOWER_NOTIFICATION_EMAIL_SERVER</code>, <code>WATCHTOWER_NOTIFICATION_EMAIL_FROM</code>) are automatically converted to a Shoutrrr SMTP URL internally.</p>"},{"location":"notifications/overview/#common_smtp_configurations","title":"Common SMTP Configurations","text":"GmailAWS SESMicrosoft 365Generic (SSL)Generic (Plain) Property Value Port <code>587</code> Encryption <code>ExplicitTLS</code> UseStartTLS <code>Yes</code> <pre><code>smtp://${USER}:${PASSWORD}@smtp.gmail.com:587/?fromaddress=${FROM}&amp;toaddresses=${TO}&amp;encryption=ExplicitTLS&amp;usestarttls=yes&amp;timeout=30s\n</code></pre> <p>Note</p> <p>For Gmail, use an App Password if two-factor authentication is enabled.</p> Property Value Port <code>587</code> Encryption <code>ExplicitTLS</code> UseStartTLS <code>Yes</code> <pre><code>smtp://${USER}:${PASSWORD}@email-smtp.us-east-1.amazonaws.com:587/?fromaddress=${FROM}&amp;toaddresses=${TO}&amp;encryption=ExplicitTLS&amp;usestarttls=yes&amp;timeout=30s\n</code></pre> Property Value Port <code>587</code> Encryption <code>ExplicitTLS</code> UseStartTLS <code>Yes</code> <pre><code>smtp://${USER}:${PASSWORD}@smtp.office365.com:587/?fromaddress=${FROM}&amp;toaddresses=${TO}&amp;encryption=ExplicitTLS&amp;usestarttls=yes&amp;timeout=30s\n</code></pre> Property Value Port <code>465</code> Encryption <code>ImplicitTLS</code> UseStartTLS <code>No</code> <pre><code>smtp://${USER}:${PASSWORD}@smtp.example.com:465/?fromaddress=${FROM}&amp;toaddresses=${TO}&amp;encryption=ImplicitTLS&amp;usestarttls=no&amp;timeout=30s\n</code></pre> Property Value Port <code>25</code> Encryption <code>None</code> UseStartTLS <code>No</code> <pre><code>smtp://${USER}:${PASSWORD}@smtp.example.com:25/?fromaddress=${FROM}&amp;toaddresses=${TO}&amp;encryption=None&amp;usestarttls=no&amp;timeout=30s\n</code></pre>"},{"location":"notifications/overview/#notes","title":"Notes","text":"<ul> <li> <p>Timeout:</p> <ul> <li>The default SMTP timeout is 10 seconds.</li> <li>If you experience timeouts (e.g., <code>failed to send: timed out: using smtp</code>), add <code>&amp;timeout=30s</code> to the URL to allow more time for server responses, especially with proxies or slow networks.</li> </ul> </li> <li> <p>Authentication:</p> <ul> <li>Use <code>&amp;auth=Plain</code> for username/password authentication (default if credentials provided).</li> <li>For OAuth2 (e.g., Gmail with app-specific passwords), use <code>&amp;auth=OAuth2</code>.</li> </ul> </li> <li> <p>Testing:</p> <ul> <li>Install Shoutrrr using one of the various installation methods.</li> <li>Test your URL with the Shoutrrr CLI:   <pre><code>shoutrrr send -u &lt;URL&gt; -m \"Test message\"\n</code></pre></li> </ul> </li> <li> <p>Proxy Issues:</p> <ul> <li>If using a Docker proxy (e.g., <code>tcp://dockerproxy:2375</code>), ensure it allows outbound connections to <code>${SMTP_HOST}:${SMTP_PORT}</code>.</li> <li>Test connectivity with <code>telnet ${SMTP_HOST} ${SMTP_PORT}</code> inside the container.</li> </ul> </li> </ul>"},{"location":"notifications/overview/#example_legacy_email_configuration","title":"Example Legacy Email Configuration","text":"Docker CLIDocker CLI (SMTP Relay)Docker ComposeDocker Compose (SMTP Relay) <pre><code>docker run -d \\\n  --name watchtower \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -e WATCHTOWER_NOTIFICATIONS=email \\\n  -e WATCHTOWER_NOTIFICATION_EMAIL_FROM=sender@example.com \\\n  -e WATCHTOWER_NOTIFICATION_EMAIL_TO=recipient@example.com \\\n  -e WATCHTOWER_NOTIFICATION_EMAIL_SERVER=smtp.example.com \\\n  -e WATCHTOWER_NOTIFICATION_EMAIL_SERVER_PORT=587 \\\n  -e WATCHTOWER_NOTIFICATION_EMAIL_SERVER_USER=user \\\n  -e WATCHTOWER_NOTIFICATION_EMAIL_SERVER_PASSWORD=secret \\\n  -e WATCHTOWER_NOTIFICATION_EMAIL_DELAY=10 \\\n  nickfedor/watchtower\n</code></pre> <pre><code>docker run -d \\\n  --name watchtower \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -e WATCHTOWER_NOTIFICATIONS=email \\\n  -e WATCHTOWER_NOTIFICATION_EMAIL_FROM=sender@example.com \\\n  -e WATCHTOWER_NOTIFICATION_EMAIL_TO=recipient@example.com \\\n  -e WATCHTOWER_NOTIFICATION_EMAIL_SERVER=relay.example.com \\\n  nickfedor/watchtower\n</code></pre> <p>Note</p> <p>This assumes that you already have an SMTP server up and running that you can connect to. If you don't or you want to bring up Watchtower with your own simple SMTP relay, then check out the Docker Compose example.</p> <pre><code>services:\n  watchtower:\n    image: nickfedor/watchtower:latest\n    environment:\n      WATCHTOWER_NOTIFICATIONS: email\n      WATCHTOWER_NOTIFICATION_EMAIL_FROM: sender@example.com\n      WATCHTOWER_NOTIFICATION_EMAIL_TO: recipient@example.com\n      WATCHTOWER_NOTIFICATION_EMAIL_SERVER: smtp.example.com\n      WATCHTOWER_NOTIFICATION_EMAIL_SERVER_PORT: 587\n      WATCHTOWER_NOTIFICATION_EMAIL_SERVER_USER: user\n      WATCHTOWER_NOTIFICATION_EMAIL_SERVER_PASSWORD: secret\n      WATCHTOWER_NOTIFICATION_EMAIL_DELAY: 10\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n</code></pre> <pre><code>services:\n  watchtower:\n    image: nickfedor/watchtower:latest\n    environment:\n      WATCHTOWER_NOTIFICATIONS: email\n      WATCHTOWER_NOTIFICATION_EMAIL_FROM: sender@example.com\n      WATCHTOWER_NOTIFICATION_EMAIL_TO: recipient@example.com\n      WATCHTOWER_NOTIFICATION_EMAIL_SERVER: relay.example.com\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n</code></pre> <p>Note</p> <p>The example assumes that your domain is called <code>example.com</code> and that you are going to use a valid certificate for <code>smtp.example.com</code>.</p> <p>This hostname has to be used as <code>WATCHTOWER_NOTIFICATION_EMAIL_SERVER</code>, otherwise the TLS connection will fail with <code>Failed to send notification email</code> or <code>connection: connection refused</code> errors.</p> <p>We also have to add a network for this setup in order to add an alias to it.</p> <p>If you also want to enable DKIM or other features on the SMTP server, then you will find more information at freinet/postfix-relay</p>"},{"location":"notifications/overview/#legacy_notification_flags","title":"Legacy Notification Flags","text":""},{"location":"notifications/overview/#email_from","title":"Email From","text":"<p>The e-mail address from which notifications will be sent.</p> <pre><code>            Argument: --notification-email-from\nEnvironment Variable: WATCHTOWER_NOTIFICATION_EMAIL_FROM\n                Type: String\n             Default: None\n</code></pre>"},{"location":"notifications/overview/#email_to","title":"Email To","text":"<p>The e-mail address to which notifications will be sent.</p> <pre><code>            Argument: --notification-email-to\nEnvironment Variable: WATCHTOWER_NOTIFICATION_EMAIL_TO\n                Type: String\n             Default: None\n</code></pre>"},{"location":"notifications/overview/#email_server","title":"Email Server","text":"<p>The SMTP server (IP or FQDN) to send notifications through.</p> <pre><code>            Argument: --notification-email-server\nEnvironment Variable: WATCHTOWER_NOTIFICATION_EMAIL_SERVER\n                Type: String\n             Default: None\n</code></pre>"},{"location":"notifications/overview/#email_server_tls_skip_verify","title":"Email Server TLS Skip Verify","text":"<p>Skip verification of the server certificate when using TLS.</p> <pre><code>            Argument: --notification-email-server-tls-skip-verify\nEnvironment Variable: WATCHTOWER_NOTIFICATION_EMAIL_SERVER_TLS_SKIP_VERIFY\n                Type: Boolean\n             Default: false\n</code></pre>"},{"location":"notifications/overview/#email_server_user","title":"Email Server User","text":"<p>The username for the SMTP server if it requires authentication.</p> <pre><code>            Argument: --notification-email-server-user\nEnvironment Variable: WATCHTOWER_NOTIFICATION_EMAIL_SERVER_USER\n                Type: String\n             Default: None\n</code></pre>"},{"location":"notifications/overview/#email_server_password","title":"Email Server Password","text":"<p>The password for the SMTP server if it requires authentication.</p> <pre><code>            Argument: --notification-email-server-password\nEnvironment Variable: WATCHTOWER_NOTIFICATION_EMAIL_SERVER_PASSWORD\n                Type: String\n             Default: None\n</code></pre> <p>Note</p> <p>This option can also reference a file, in which case the contents of the file are used.</p>"},{"location":"notifications/overview/#email_subject_tag","title":"Email Subject Tag","text":"<p>Subject prefix tag for notifications via mail.</p> <pre><code>            Argument: --notification-email-subjecttag\nEnvironment Variable: WATCHTOWER_NOTIFICATION_EMAIL_SUBJECTTAG\n                Type: String\n             Default: \"\"\n</code></pre>"},{"location":"notifications/overview/#email_server_port","title":"Email Server Port","text":"<p>The port the SMTP server listens on.</p> <pre><code>            Argument: --notification-email-server-port\nEnvironment Variable: WATCHTOWER_NOTIFICATION_EMAIL_SERVER_PORT\n                Type: Integer\n             Default: 25\n</code></pre>"},{"location":"notifications/overview/#email_delay","title":"Email Delay","text":"<p>The delay (in seconds) between sending notifications if multiple containers are updated at once.</p> <pre><code>            Argument: --notification-email-delay\nEnvironment Variable: WATCHTOWER_NOTIFICATION_EMAIL_DELAY\n                Type: Integer\n             Default: None\n</code></pre>"},{"location":"notifications/overview/#transitioning_from_legacy_email_notifications_to_shoutrrr","title":"Transitioning from Legacy Email Notifications to Shoutrrr","text":"<p>Watchtower includes a <code>watchtower notify-upgrade</code> command to convert legacy flags to a Shoutrrr URL.</p> <p>The output is written to a temporary file, which you can copy using:</p> <pre><code>docker cp &lt;CONTAINER&gt;:&lt;FILE_PATH&gt; ./watchtower-notifications.env\n</code></pre>"},{"location":"notifications/overview/#example_walkthrough","title":"Example Walkthrough","text":"<p>Example Legacy Configuration:</p> Docker CLIDocker Compose <pre><code>docker run -d \\\n  --name watchtower \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -e WATCHTOWER_NOTIFICATIONS=email \\\n  -e WATCHTOWER_NOTIFICATION_EMAIL_SERVER=smtp.example.com \\\n  -e WATCHTOWER_NOTIFICATION_EMAIL_SERVER_PORT=587 \\\n  -e WATCHTOWER_NOTIFICATION_EMAIL_SERVER_USER=user@example.com \\\n  -e WATCHTOWER_NOTIFICATION_EMAIL_SERVER_PASSWORD=secret \\\n  -e WATCHTOWER_NOTIFICATION_EMAIL_FROM=sender@example.com \\\n  -e WATCHTOWER_NOTIFICATION_EMAIL_TO=recipient@example.com \\\n  nickfedor/watchtower\n</code></pre> <pre><code>services:\n  watchtower:\n    image: nickfedor/watchtower:latest\n    environment:\n      WATCHTOWER_NOTIFICATIONS: email\n      WATCHTOWER_NOTIFICATION_EMAIL_SERVER: smtp.example.com\n      WATCHTOWER_NOTIFICATION_EMAIL_SERVER_PORT: 587\n      WATCHTOWER_NOTIFICATION_EMAIL_SERVER_USER: user@example.com\n      WATCHTOWER_NOTIFICATION_EMAIL_SERVER_PASSWORD: secret\n      WATCHTOWER_NOTIFICATION_EMAIL_FROM: sender@example.com\n      WATCHTOWER_NOTIFICATION_EMAIL_TO: recipient@example.com\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n</code></pre> <ol> <li> <p>Run the following CLI command:</p> <pre><code>docker compose exec watchtower watchtower notify-upgrade\n</code></pre> <p>Converted Shoutrrr URL:</p> <pre><code>smtp://user@example.com:secret@smtp.example.com:587/?fromaddress=sender@example.com&amp;toaddresses=recipient@example.com&amp;encryption=ExplicitTLS&amp;usestarttls=yes\n</code></pre> </li> <li> <p>Replace the legacy flags with:</p> </li> </ol> Docker CLIDocker Compose <pre><code>docker run -d \\\n  --name watchtower \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -e WATCHTOWER_NOTIFICATIONS=shoutrrr \\\n  -e WATCHTOWER_NOTIFICATION_URL=smtp://user@example.com:secret@smtp.example.com:587/?fromaddress=sender@example.com&amp;toaddresses=recipient@example.com&amp;encryption=ExplicitTLS&amp;usestarttls=yes \\\n  -e WATCHTOWER_NOTIFICATION_EMAIL_DELAY=10 \\\n  -e WATCHTOWER_NOTIFICATION_EMAIL_SUBJECTTAG=Watchtower \\\n  nickfedor/watchtower\n</code></pre> <pre><code>services:\n  watchtower:\n    image: nickfedor/watchtower:latest\n    environment:\n      WATCHTOWER_NOTIFICATIONS: shoutrrr\n      WATCHTOWER_NOTIFICATION_URL: smtp://user@example.com:secret@smtp.example.com:587/?fromaddress=sender@example.com&amp;toaddresses=recipient@example.com&amp;encryption=ExplicitTLS&amp;usestarttls=yes\n      WATCHTOWER_NOTIFICATION_EMAIL_DELAY: \"10\"\n      WATCHTOWER_NOTIFICATION_EMAIL_SUBJECTTAG: Watchtower\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n</code></pre> <p>Note</p> <p>Avoid using unrecognized flags like <code>WATCHTOWER_NOTIFICATION_EMAIL_SERVER_SSL</code>, as they are ignored and may cause confusion.</p> <p>Use <code>WATCHTOWER_NOTIFICATION_EMAIL_SERVER_TLS_SKIP_VERIFY</code> to disable TLS verification if needed (not recommended for production).</p>"},{"location":"notifications/overview/#slack_notifications","title":"Slack Notifications","text":""},{"location":"notifications/overview/#example_slack_configuration","title":"Example Slack Configuration","text":"Docker CLIDocker Compose <pre><code>docker run -d \\\n  --name watchtower \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -e WATCHTOWER_NOTIFICATIONS=slack \\\n  -e WATCHTOWER_NOTIFICATION_SLACK_HOOK_URL=\"https://hooks.slack.com/services/xxx/yyyyyyyyyyyyyyy\" \\\n  -e WATCHTOWER_NOTIFICATION_SLACK_IDENTIFIER=watchtower-server-1 \\\n  -e WATCHTOWER_NOTIFICATION_SLACK_CHANNEL=#my-custom-channel \\\n  nickfedor/watchtower\n</code></pre> <pre><code>services:\n  watchtower:\n    image: nickfedor/watchtower:latest\n    environment:\n      WATCHTOWER_NOTIFICATIONS: slack\n      WATCHTOWER_NOTIFICATION_SLACK_HOOK_URL: \"https://hooks.slack.com/services/xxx/yyyyyyyyyyyyyyy\"\n      WATCHTOWER_NOTIFICATION_SLACK_IDENTIFIER: watchtower-server-1\n      WATCHTOWER_NOTIFICATION_SLACK_CHANNEL: \"#my-custom-channel\"\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n</code></pre>"},{"location":"notifications/overview/#slack_configuration_options","title":"Slack Configuration Options","text":"<p>To receive notifications in Slack, add <code>slack</code> to the <code>--notifications</code> option or the <code>WATCHTOWER_NOTIFICATIONS</code> environment variable.</p> <p>Watchtower supports the following Slack-related options:</p>"},{"location":"notifications/overview/#slack_hook_url","title":"Slack Hook URL","text":"<p>The Slack webhook URL for notifications.</p> <pre><code>            Argument: --notification-slack-hook-url\nEnvironment Variable: WATCHTOWER_NOTIFICATION_SLACK_HOOK_URL\n                Type: String\n             Default: None\n</code></pre> <p>Note</p> <p>This option can also reference a file, in which case the contents of the file are used.</p>"},{"location":"notifications/overview/#slack_identifier","title":"Slack Identifier","text":"<p>Custom name under which messages are sent.</p> <pre><code>            Argument: --notification-slack-identifier\nEnvironment Variable: WATCHTOWER_NOTIFICATION_SLACK_IDENTIFIER\n                Type: String\n             Default: watchtower\n</code></pre>"},{"location":"notifications/overview/#slack_channel","title":"Slack Channel","text":"<p>A string which overrides the webhook's default channel (optional).</p> <pre><code>            Argument: --notification-slack-channel\nEnvironment Variable: WATCHTOWER_NOTIFICATION_SLACK_CHANNEL\n                Type: String\n             Default: None\n</code></pre>"},{"location":"notifications/overview/#microsoft_teams_notifications","title":"Microsoft Teams Notifications","text":"Docker CLIDocker Compose <pre><code>docker run -d \\\n  --name watchtower \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -e WATCHTOWER_NOTIFICATIONS=msteams \\\n  -e WATCHTOWER_NOTIFICATION_MSTEAMS_HOOK_URL=\"https://outlook.office.com/webhook/xxxxxxxx@xxxxxxx/IncomingWebhook/yyyyyyyy/zzzzzzzzzz\" \\\n  -e WATCHTOWER_NOTIFICATION_MSTEAMS_USE_LOG_DATA=true \\\n  nickfedor/watchtower\n</code></pre> <pre><code>services:\n  watchtower:\n    image: nickfedor/watchtower:latest\n    environment:\n      WATCHTOWER_NOTIFICATIONS: msteams\n      WATCHTOWER_NOTIFICATION_MSTEAMS_HOOK_URL: \"https://outlook.office.com/webhook/xxxxxxxx@xxxxxxx/IncomingWebhook/yyyyyyyy/zzzzzzzzzz\"\n      WATCHTOWER_NOTIFICATION_MSTEAMS_USE_LOG_DATA: true\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n</code></pre>"},{"location":"notifications/overview/#microsoft_teams_configuration_options","title":"Microsoft Teams Configuration Options","text":"<p>To receive notifications in Microsoft Teams, add <code>msteams</code> to the <code>--notifications</code> option or the <code>WATCHTOWER_NOTIFICATIONS</code> environment variable.</p> <p>Watchtower supports the following Microsoft Teams-related options:</p>"},{"location":"notifications/overview/#msteams_hook_url","title":"MSTeams Hook URL","text":"<p>The Microsoft Teams webhook URL for notifications.</p> <pre><code>            Argument: --notification-msteams-hook\nEnvironment Variable: WATCHTOWER_NOTIFICATION_MSTEAMS_HOOK_URL\n                Type: String\n             Default: None\n</code></pre> <p>Note</p> <p>This option can also reference a file, in which case the contents of the file are used.</p>"},{"location":"notifications/overview/#msteams_use_log_data","title":"MSTeams Use Log Data","text":"<p>Enable sending keys/values filled by <code>log.WithField</code> or <code>log.WithFields</code> as Microsoft Teams message facts.</p> <pre><code>            Argument: --notification-msteams-data\nEnvironment Variable: WATCHTOWER_NOTIFICATION_MSTEAMS_USE_LOG_DATA\n                Type: Boolean\n             Default: false\n</code></pre>"},{"location":"notifications/overview/#gotify_notifications","title":"Gotify Notifications","text":"Docker CLIDocker Compose <pre><code>docker run -d \\\n  --name watchtower \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -e WATCHTOWER_NOTIFICATIONS=gotify \\\n  -e WATCHTOWER_NOTIFICATION_GOTIFY_URL=\"https://my.gotify.tld/\" \\\n  -e WATCHTOWER_NOTIFICATION_GOTIFY_TOKEN=\"SuperSecretToken\" \\\n  -e WATCHTOWER_NOTIFICATION_GOTIFY_TLS_SKIP_VERIFY=true \\\n  nickfedor/watchtower\n</code></pre> <pre><code>services:\n  watchtower:\n    image: nickfedor/watchtower:latest\n    environment:\n      WATCHTOWER_NOTIFICATIONS: gotify\n      WATCHTOWER_NOTIFICATION_GOTIFY_URL: \"https://my.gotify.tld/\"\n      WATCHTOWER_NOTIFICATION_GOTIFY_TOKEN: \"SuperSecretToken\"\n      WATCHTOWER_NOTIFICATION_GOTIFY_TLS_SKIP_VERIFY: true\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n</code></pre>"},{"location":"notifications/overview/#gotify_configuration_options","title":"Gotify Configuration Options","text":"<p>To push a notification to your Gotify instance, add <code>gotify</code> to the <code>--notifications</code> option or the <code>WATCHTOWER_NOTIFICATIONS</code> environment variable.</p> <p>Watchtower supports the following Gotify-related options:</p>"},{"location":"notifications/overview/#gotify_url","title":"Gotify URL","text":"<p>The URL of the Gotify instance.</p> <pre><code>            Argument: --notification-gotify-url\nEnvironment Variable: WATCHTOWER_NOTIFICATION_GOTIFY_URL\n                Type: String\n             Default: None\n</code></pre>"},{"location":"notifications/overview/#gotify_token","title":"Gotify Token","text":"<p>The app token for the Gotify instance.</p> <pre><code>            Argument: --notification-gotify-token\nEnvironment Variable: WATCHTOWER_NOTIFICATION_GOTIFY_TOKEN\n                Type: String\n             Default: None\n</code></pre> <p>Note</p> <p>This option can also reference a file, in which case the contents of the file are used.</p>"},{"location":"notifications/overview/#gotify_tls_skip_verify","title":"Gotify TLS Skip Verify","text":"<p>Skip verification of the server certificate when using TLS.</p> <pre><code>            Argument: --notification-gotify-tls-skip-verify\nEnvironment Variable: WATCHTOWER_NOTIFICATION_GOTIFY_TLS_SKIP_VERIFY\n                Type: Boolean\n             Default: false\n</code></pre>"},{"location":"notifications/overview/#signal_notifications","title":"Signal Notifications","text":"<p>Watchtower uses Shoutrrr's signal service to send Signal notifications.</p> <p>Signal notifications require a Signal API server that can send messages on behalf of a registered Signal account. This is typically done using signal-cli-rest-api or secured-signal-api.</p>"},{"location":"notifications/overview/#setting_up_signal_api_server","title":"Setting up Signal API Server","text":"<ol> <li>Phone Number: A dedicated phone number registered with Signal</li> <li>API Server: A server running signal-cli with REST API capabilities</li> <li>Account Linking: Linking the server as a secondary device to your Signal account</li> <li>Optional Security Layer: Authentication and endpoint restrictions via a proxy</li> </ol> <p>The server must be able to receive SMS verification codes during initial setup and maintain a persistent connection to Signal's servers.</p>"},{"location":"notifications/overview/#example_signal_configuration","title":"Example Signal Configuration","text":"Docker CLIDocker Compose <pre><code>docker run -d \\\n  --name watchtower \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -e WATCHTOWER_NOTIFICATION_URL=signal://localhost:8080/+1234567890/+0987654321 \\\n  nickfedor/watchtower\n</code></pre> <pre><code>services:\n  watchtower:\n    image: nickfedor/watchtower:latest\n    environment:\n      WATCHTOWER_NOTIFICATION_URL: signal://localhost:8080/+1234567890/+0987654321\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n</code></pre>"},{"location":"notifications/overview/#signal_url_format","title":"Signal URL Format","text":"<pre><code>signal://[user:password@]host:port/source_phone/recipient1/recipient2\n</code></pre>"},{"location":"notifications/overview/#parameters","title":"Parameters","text":"<ul> <li><code>host</code>: Signal API server hostname or IP address</li> <li><code>port</code>: Signal API server port (default: 8080)</li> <li><code>user</code>: Username for HTTP Basic Authentication (optional)</li> <li><code>password</code>: Password for HTTP Basic Authentication (optional)</li> <li><code>source_phone</code>: Your Signal phone number with country code (e.g., +1234567890)</li> <li><code>recipient1, recipient2</code>: Phone numbers or group IDs to send to</li> </ul>"},{"location":"notifications/overview/#tls_configuration","title":"TLS Configuration","text":"<ul> <li>Use <code>signal://</code> for HTTPS (default, recommended)</li> <li>Use <code>signal://...?disabletls=yes</code> for HTTP (insecure, for local testing only)</li> </ul>"},{"location":"notifications/overview/#examples","title":"Examples","text":"<p>Send to a single phone number:</p> <pre><code>signal://localhost:8080/+1234567890/+0987654321\n</code></pre> <p>Send to multiple recipients:</p> <pre><code>signal://localhost:8080/+1234567890/+0987654321/+1123456789/group.testgroup\n</code></pre> <p>Send to a group:</p> <pre><code>signal://localhost:8080/+1234567890/group.abcdefghijklmnop=\n</code></pre> <p>With authentication:</p> <pre><code>signal://user:password@localhost:8080/+1234567890/+0987654321\n</code></pre> <p>With API token (Bearer auth):</p> <pre><code>signal://localhost:8080/+1234567890/+0987654321?token=YOUR_API_TOKEN\n</code></pre> <p>Using HTTP instead of HTTPS:</p> <pre><code>signal://localhost:8080/+1234567890/+0987654321?disabletls=yes\n</code></pre>"},{"location":"notifications/overview/#signal_attachments","title":"Signal Attachments","text":"<p>The Signal service supports sending base64-encoded attachments:</p> <pre><code>shoutrrr send \"signal://localhost:8080/+1234567890/+0987654321\" \\\n  \"Message with attachment\" \\\n  --attachments \"base64data1,base64data2\"\n</code></pre> <p>Note</p> <p>Attachments must be provided as base64-encoded data. The API server handles MIME type detection and file handling.</p>"},{"location":"notifications/template-preview/","title":"Template Preview","text":"<pre>loading wasm...</pre> Template Input {{- if .Report -}}  {{- with .Report -}}    {{len .Scanned}} Scanned, {{len .Updated}} Updated, {{len .Failed}} Failed, {{len .Restarted}} Restarted    {{- if ( or .Updated .Failed .Restarted ) -}}      {{- range .Updated}} - {{.Name}} ({{.ImageName}}): {{.CurrentImageID.ShortID}} updated to {{.LatestImageID.ShortID}}      {{- end -}}      {{- range .Restarted}} - {{.Name}} ({{.ImageName}}): {{.State}}      {{- end -}}      {{- range .Fresh}} - {{.Name}} ({{.ImageName}}): {{.State}}      {{- end -}}      {{- range .Skipped}} - {{.Name}} ({{.ImageName}}): {{.State}}: {{.Error}}      {{- end -}}      {{- range .Failed}} - {{.Name}} ({{.ImageName}}): {{.State}}: {{.Error}}      {{- end -}}    {{- end -}}  {{- end -}} {{- else -}}  {{range .Entries -}}{{.Message}}{{\"\\n\"}}{{- end -}} {{- end -}}  Container report          Skipped:                   Scanned:                   Updated:                   Failed:                   Restarted:                   Fresh:                   Stale:           Log entries          Error:                   Warning:                   Info:                   Debug:"},{"location":"notifications/templates/","title":"Templates","text":""},{"location":"notifications/templates/#overview","title":"Overview","text":"<p>You can customize the message posted by setting a notification template.</p>"},{"location":"notifications/templates/#notification_template","title":"Notification Template","text":"<p>Sets the Go template used for formatting notification messages.</p> <pre><code>            Argument: --notification-template\nEnvironment Variable: WATCHTOWER_NOTIFICATION_TEMPLATE\n                Type: String\n             Default: See default templates below\n</code></pre>"},{"location":"notifications/templates/#notification_report","title":"Notification Report","text":"<p>Enables the session report as the notification template data, including container statuses and logs.</p> <pre><code>            Argument: --notification-report\nEnvironment Variable: WATCHTOWER_NOTIFICATION_REPORT\n                Type: Boolean\n             Default: false\n</code></pre> <p>The template is a Go template that processes either a list of Logrus log entries or a <code>notifications.Data</code> struct, depending on the <code>--notification-report</code> flag.</p>"},{"location":"notifications/templates/#simple_templates","title":"Simple Templates","text":"<p>Simple templates are used when <code>--notification-report</code> is not set, formatting individual log entries as they occur.</p> Default Simple Template<pre><code>{{- range $i, $e := . -}}\n{{- if $i}}{{- println -}}{{- end -}}\n{{- $msg := $e.Message -}}\n{{- if eq $msg \"Found new image\" -}}\n    Found new image: {{$e.Data.image}} ({{with $e.Data.new_id}}{{.}}{{else}}unknown{{end}})\n{{- else if eq $msg \"Stopping container\" -}}\n    Stopped stale container: {{$e.Data.container}} ({{with $e.Data.id}}{{.}}{{else}}unknown{{end}})\n{{- else if eq $msg \"Started new container\" -}}\n    Started new container: {{$e.Data.container}} ({{with $e.Data.new_id}}{{.}}{{else}}unknown{{end}})\n{{- else if eq $msg \"Removing image\" -}}\n    Removed stale image: {{with $e.Data.image_id}}{{.}}{{else}}unknown{{end}}\n{{- else if $e.Data -}}\n    {{$msg}} | {{range $k, $v := $e.Data -}}{{$k}}={{$v}} {{- end}}\n{{- else -}}\n    {{$msg}}\n{{- end -}}\n{{- end -}}\n</code></pre> <ul> <li>This template processes <code>info</code>-level log entries in real-time, formatting key update events in past tense with container and image details from <code>logrus</code> fields.</li> <li>It sends each event immediately in legacy mode, mimicking a step-by-step log.</li> </ul>"},{"location":"notifications/templates/#using_simple_templates_in_the_preview_tool","title":"Using Simple Templates in the Preview Tool","text":"<p>The Template Preview Tool uses a <code>notifications.Data</code> struct with <code>.Entries</code> as the log list.</p> <p>Note</p> <p>To use the simple template in the preview tool, modify the range to <code>{{- range $i, $e := .Entries -}}</code> to match the data structure.</p> Example Simple Template for the Template Preview Tool<pre><code>{{- range $i, $e := .Entries -}}\n{{- if $i}}{{- println -}}{{- end -}}\n{{- $msg := $e.Message -}}\n{{- if eq $msg \"Found new image\" -}}\n    Found new image: {{$e.Data.image}} ({{with $e.Data.new_id}}{{.}}{{else}}unknown{{end}})\n{{- else if eq $msg \"Stopping container\" -}}\n    Stopped stale container: {{$e.Data.container}} ({{with $e.Data.id}}{{.}}{{else}}unknown{{end}})\n{{- else if eq $msg \"Started new container\" -}}\n    Started new container: {{$e.Data.container}} ({{with $e.Data.new_id}}{{.}}{{else}}unknown{{end}})\n{{- else if eq $msg \"Removing image\" -}}\n    Removed stale image: {{with $e.Data.image_id}}{{.}}{{else}}unknown{{end}}\n{{- else if $e.Data -}}\n    {{$msg}} | {{range $k, $v := $e.Data -}}{{$k}}={{$v}} {{- end}}\n{{- else -}}\n    {{$msg}}\n{{- end -}}\n{{- end -}}\n</code></pre> <p>Example output for a log entry with <code>msg=\"Found new image\"</code>:</p> <pre><code>Found new image: repo/image:latest (abcdef123456)\n</code></pre>"},{"location":"notifications/templates/#report_templates","title":"Report Templates","text":"<p>When <code>--notification-report</code> is set, the template processes a <code>notifications.Data</code> struct containing a session report and log entries.</p> Default Report Template<pre><code>{{- if .Report -}}\n  {{- with .Report -}}\n    {{len .Scanned}} Scanned, {{len .Updated}} Updated, {{len .Restarted}} Restarted, {{len .Failed}} Failed\n    {{- if ( or .Updated .Restarted .Failed ) -}}\n      {{- range .Updated}}\n- {{.Name}} ({{.ImageName}}): {{.CurrentImageID.ShortID}} updated to {{.LatestImageID.ShortID}}\n      {{- end -}}\n      {{- range .Fresh}}\n- {{.Name}} ({{.ImageName}}): {{.State}}\n      {{- end -}}\n      {{- range .Restarted}}\n- {{.Name}} ({{.ImageName}}): {{.State}}\n      {{- end -}}\n      {{- range .Skipped}}\n- {{.Name}} ({{.ImageName}}): {{.State}}: {{.Error}}\n      {{- end -}}\n      {{- range .Failed}}\n- {{.Name}} ({{.ImageName}}): {{.State}}: {{.Error}}\n      {{- end -}}\n    {{- end -}}\n  {{- end -}}\n{{- if .Entries -}}\n\nLogs:\n{{- end -}}\n{{range .Entries -}}{{.Time.Format \"2006-01-02T15:04:05Z07:00\"}} [{{.Level}}] {{.Message}}{{\"\\n\"}}{{- end -}}\n{{- end -}}\n</code></pre> <ul> <li>This template generates a summary of container statuses (scanned, updated, failed, etc.) followed by logs, used for notifications like email or Slack messages.</li> </ul>"},{"location":"notifications/templates/#example_usage","title":"Example Usage","text":"Docker CLIDocker Compose <pre><code>docker run -d \\\n  --name watchtower \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -e WATCHTOWER_NOTIFICATION_REPORT=\"true\" \\\n  -e WATCHTOWER_NOTIFICATION_TEMPLATE=\"\\\n{{- if .Report -}}\n  {{- with .Report -}}\n{{len .Scanned}} Scanned, {{len .Updated}} Updated, {{len .Restarted}} Restarted, {{len .Failed}} Failed\n{{- if ( or .Updated .Restarted .Failed ) -}}\n      {{- range .Updated -}}\n- {{.Name}} ({{.ImageName}}): {{.CurrentImageID.ShortID}} updated to {{.LatestImageID.ShortID}}\n      {{- end -}}\n      {{- range .Fresh -}}\n- {{.Name}} ({{.ImageName}}): {{.State}}\n      {{- end -}}\n      {{- range .Restarted -}}\n- {{.Name}} ({{.ImageName}}): {{.State}}\n      {{- end -}}\n      {{- range .Skipped -}}\n- {{.Name}} ({{.ImageName}}): {{.State}}: {{.Error}}\n      {{- end -}}\n      {{- range .Failed -}}\n- {{.Name}} ({{.ImageName}}): {{.State}}: {{.Error}}\n      {{- end -}}\n{{- end -}}\n  {{- end -}}\n{{- if .Entries -}}\n\nLogs:\n{{- end -}}\n{{- range .Entries -}}{{.Time.Format \\\"2006-01-02T15:04:05Z07:00\\\"}} [{{.Level}}] {{.Message}}{{\\\"\\n\\\"}}{{- end -}}\n{{- end -}}\n\" \\\n  watchtower-image\n</code></pre> <pre><code>services:\n  watchtower:\n    image: watchtower-image\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n    environment:\n      WATCHTOWER_NOTIFICATION_REPORT: \"true\"\n      WATCHTOWER_NOTIFICATION_URL: &gt;\n        discord://token@channel\n        slack://watchtower@token-a/token-b/token-c\n      WATCHTOWER_NOTIFICATION_TEMPLATE: |\n        {{- if .Report -}}\n          {{- with .Report -}}\n        {{len .Scanned}} Scanned, {{len .Updated}} Updated, {{len .Restarted}} Restarted, {{len .Failed}} Failed\n        {{- if ( or .Updated .Restarted .Failed ) -}}\n            {{- range .Updated -}}\n        - {{.Name}} ({{.ImageName}}): {{.CurrentImageID.ShortID}} updated to {{.LatestImageID.ShortID}}\n            {{- end -}}\n            {{- range .Fresh -}}\n        - {{.Name}} ({{.ImageName}}): {{.State}}\n            {{- end -}}\n            {{- range .Restarted -}}\n        - {{.Name}} ({{.ImageName}}): {{.State}}\n            {{- end -}}\n            {{- range .Skipped -}}\n        - {{.Name}} ({{.ImageName}}): {{.State}}: {{.Error}}\n            {{- end -}}\n            {{- range .Failed -}}\n        - {{.Name}} ({{.ImageName}}): {{.State}}: {{.Error}}\n            {{- end -}}\n        {{- end -}}\n          {{- end -}}\n        {{- if .Entries -}}\n\n        Logs:\n        {{- end -}}\n        {{- range .Entries -}}{{.Time.Format \"2006-01-02T15:04:05Z07:00\"}} [{{.Level}}] {{.Message}}{{\"\\n\"}}{{- end -}}\n        {{- end -}}\n</code></pre> <p>Example output for a session with one updated container, one restarted container, and one error log:</p> <pre><code>5 Scanned, 1 Updated, 1 Restarted, 0 Failed\n- /container (repo/image:latest): abcdef12 updated to 34567890\n- /restarted-container (repo/image:latest): Restarted\n\nLogs:\n2025-08-20T06:00:13-07:00 [error] Operation failed. Try again later.\n</code></pre>"},{"location":"notifications/templates/#customizing_templates","title":"Customizing Templates","text":"<p>You can create custom templates to format notifications differently.</p> <p>Use the Template Preview Tool to test your templates interactively.</p> <p>Note</p> <p>When testing simple templates in the preview tool, ensure the range iterates over <code>.Entries</code> (e.g., <code>{{- range $i, $e := .Entries -}}</code>) to match the <code>notifications.Data</code> struct.</p>"},{"location":"notifications/templates/#additional_resources","title":"Additional Resources","text":"<ul> <li>For detailed template syntax, refer to the Go Template documentation.</li> <li>For log entry fields, see the Logrus Entry documentation.</li> </ul>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#overview","title":"Overview","text":"<p>Despite offering extensive configuration options, Watchtower's default settings are suitable for most deployments. If you need to modify the configuration, then review the available documentation.</p>"},{"location":"quickstart/#docker_cli","title":"Docker CLI","text":"<p>Docker Run CLI Reference</p> Pull and run Watchtower<pre><code>docker run -d \\\n  --name watchtower \\\n  --restart unless-stopped \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  nickfedor/watchtower\n</code></pre>"},{"location":"quickstart/#docker_compose","title":"Docker Compose","text":"<p>Docker Compose File Reference</p> <ol> <li> <p>Obtain the example Docker Compose file:</p> Download via PowerShell (Windows)Download via Bash (Linux)Copy <pre><code>iwr -Uri https://raw.githubusercontent.com/nicholas-fedor/watchtower/refs/heads/main/examples/default/docker-compose.yaml -OutFile docker-compose.yaml\n</code></pre> <pre><code>curl -L https://raw.githubusercontent.com/nicholas-fedor/watchtower/refs/heads/main/examples/default/docker-compose.yaml -o docker-compose.yaml\n</code></pre> docker-compose.yaml<pre><code>services:\n  watchtower:\n    image: nickfedor/watchtower:latest\n    restart: unless-stopped\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n</code></pre> </li> <li> <p>Run the Compose file:</p> <pre><code>docker compose up -d\n</code></pre> </li> </ol>"},{"location":"quickstart/#expected_behavior","title":"Expected Behavior","text":"<p>When running Watchtower with its default settings:</p> <ul> <li>It will monitor all running containers on the host</li> <li>Every 24 hours, it will poll if the monitored containers have updated image digests</li> </ul> <p>If an updated image digest is detected, then Watchtower will:</p> <ul> <li>Pull the updated container image</li> <li>Perform a graceful shutdown of the target container and its dependencies</li> <li>Start a new container with the updated image while maintaining the previous container's configuration</li> </ul>"}]}